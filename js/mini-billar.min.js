var MiniBillar;
(function (MiniBillar) {
  class GameConstants {}
  GameConstants.VERSION = "1.0.2";
  GameConstants.DEVELOPMENT = false;
  GameConstants.DEBUG = false;
  GameConstants.VERBOSE = false;
  GameConstants.SHOW_DEV_BUTTONS_ON_SOLO = false;
  GameConstants.SHOW_PVBOT_CHEAT_BUTTONS = false;
  GameConstants.LOG_SERVER_INFO = false;
  GameConstants.LOG_BOT_SERVER_INFO = false;
  GameConstants.GAME_WIDTH = 1024;
  GameConstants.GAME_HEIGHT = 640;
  GameConstants.ASSETS_PATH = gameConfig.GAME_ASSETS_PATH || "assets";
  GameConstants.APPLE = "apple";
  GameConstants.ANDROID = "android";
  GameConstants.TIME_SOLO_MATCH = 120;
  GameConstants.PHYS_SCALE = 0.01;
  GameConstants.BALL_RADIUS = 1400;
  GameConstants.FRICTION = 1;
  GameConstants.POCKET_RADIUS = 2300;
  GameConstants.MIN_VELOCITY = 2;
  GameConstants.CUSHION_RESTITUTION = 0.6;
  GameConstants.BALL_RESTITUTION = 0.91;
  GameConstants.MIN_SWIPE_CHANGE_DISTANCE = 320;
  GameConstants.BITMAP_SIZE = 64;
  GameConstants.BLACK_SQUARE = "black-square";
  GameConstants.BLUE_SQUARE = "blue_square";
  GameConstants.WHITE_SQUARE = "white-square";
  GameConstants.RED_SQUARE = "red-square";
  GameConstants.ORANGE_SQUARE = "orange-square";
  GameConstants.YELLOW_SQUARE = "yellow-square";
  GameConstants.GREEN_SQUARE = "green-square";
  GameConstants.GREY_SQUARE = "grey-square";
  GameConstants.BALL_TYPE_SOLID = "ball solid";
  GameConstants.BALL_TYPE_STRIPED = "ball striped";
  GameConstants.BALL_TYPE_BLACK = "ball black";
  GameConstants.BALL_TYPE_NONE = "ball none";
  GameConstants.LEFT = "left";
  GameConstants.RIGHT = "right";
  GameConstants.UP = "up";
  GameConstants.DOWN = "down";
  GameConstants.NO_GAME = "no_game";
  GameConstants.SOLO_MODE = "solo";
  GameConstants.PVP_MODE = "pvp";
  GameConstants.PVBOT_MODE = "pvbot";
  GameConstants.NOTIFICATION_NONE = "notification none";
  GameConstants.NOTIFICATION_CUE_BALL_POTTED = "notification cue ball potted";
  GameConstants.NOTIFICATION_WRONG_BALL_POTTED =
    "notification wrong ball potted";
  GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED =
    "notification wrong ball touched";
  GameConstants.NOTIFICATION_NO_BALL_TOUCHED = "notification no ball touched";
  GameConstants.NOTIFICATION_NO_WALL_COLLISION =
    "notification no wall collision";
  GameConstants.NOTIFICATION_TIMEOUT = "notification timeout";
  GameConstants.NOTIFICATION_ILEGAL_BREAK = "notification ilegal";
  GameConstants.NOTIFICATION_YOUR_TURN = "notification your turn";
  GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS =
    "first time instructions";
  GameConstants.GAME_UNDECIDED = "game_undecided";
  GameConstants.PLAYER_WIN = "player_win";
  GameConstants.PLAYER_LOSE = "player_lose";
  GameConstants.PLAYER_RESIGNS = "player_resigns";
  GameConstants.ADVERSARY_LEFT_ROOM = "adversary_left_room";
  GameConstants.MIN_PTS_TO_GET_REWARD = 2500;
  GameConstants.MIN_PTS_UNLOCK_TABLE = 200;
  GameConstants.MIN_PTS_UNLOCK_CUE = 100;
  GameConstants.MIN_CARDS_WON_AT_A_TIME = 6;
  GameConstants.MAX_CARDS_WON_AT_A_TIME = 15;
  GameConstants.RULES_TEXT =
    "Pocket all coloured balls before the clock runs out.\n" +
    "Coloured balls add 50 pts and 10s. The cue ball deducts 20 pts.\n" +
    "Score at least " +
    GameConstants.MIN_PTS_TO_GET_REWARD.toString() +
    " pts to unlock new cues and tables!";
  GameConstants.PLAYER = "player";
  GameConstants.ADVERSARY = "adversary";
  GameConstants.MESSAGE_TYPE_PLAYER_SET = "PLAYER SET";
  GameConstants.MESSAGE_TYPE_SHOT = "SHOT";
  GameConstants.MESSAGE_TYPE_BALLS_STOPPED = "BALLS_STOPPED";
  GameConstants.MESSAGE_TYPE_CUE_ROTATION = "CUE_ROTATION";
  GameConstants.MESSAGE_TYPE_POCKET_SELECTED = "POCKET_SELECTED";
  GameConstants.MESSAGE_TYPE_CUE_BALL = "CUE_BALL";
  GameConstants.MESSAGE_TYPE_RESIGN = "RESIGN";
  GameConstants.MESSAGE_TYPE_PLAYER_QUIT_LOBBY = "PLAYER_QUIT_LOBBY";
  GameConstants.MESSAGE_TYPE_EMOTICON_SELECTED = "EMOTICON_SELECTED";
  GameConstants.MESSAGE_TYPE_CUE_BALL_SPIN_SET = "CUE_BALL_SPIN_SET";
  GameConstants.MESSAGE_TYPE_BALL_8_POCKETED = "BALL_8_POCKETED";
  GameConstants.BALLS_INITIAL_POSITIONS = [
    [-21000, 0],
    [21000, 0],
    [23424.8, 1400],
    [30699.2, -5600],
    [28274.4, 4200],
    [25849.6, 2800],
    [28274.4, -4200],
    [28274.4, 1400],
    [25849.6, 0],
    [28274.4, -1400],
    [25849.6, -2800],
    [30699.2, 0],
    [30699.2, 2800],
    [30699.2, -2800],
    [30699.2, 5600],
    [23424.8, -1400],
  ];
  GameConstants.BALLS_INITIAL_POSITIONS_SOLO = [
    [-21000, 0],
    [21000, 0],
    [23424.8, 1400],
    [30699.2, -5600 - 4000],
    [28274.4, 4200 + 4000],
    [25849.6, 2800],
    [28274.4, -4200 - 4000],
    [28274.4, 1400],
    [25849.6, 0],
    [28274.4, -1400],
    [25849.6, -2800],
    [30699.2, 0],
    [30699.2, 2800 + 4000],
    [30699.2, -2800 - 4000],
    [30699.2, 5600 + 4000],
    [23424.8, -1400],
  ];
  GameConstants.SAVED_GAME_DATA_KEY = "minibillar-data-key-1";
  MiniBillar.GameConstants = GameConstants;
})(MiniBillar || (MiniBillar = {}));

var MiniBillar;
(function (MiniBillar) {
  class GUI extends Phaser.Group {
    constructor(game) {
      super(game, null, "gui");
      if (
        MiniBillar.GameConstants.SHOW_DEV_BUTTONS_ON_SOLO &&
        MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE
      ) {
        const winButton = new Phaser.Button(
          this.game,
          920,
          25,
          "texture_atlas_0"
        );
        winButton.anchor.set(1.0, 0.5);
        winButton.inputEnabled = true;
        winButton.events.onInputDown.add(this.onClickForceWin, this);
        winButton.setFrames(
          "btn_force_win_on.png",
          "btn_force_win_off.png",
          "btn_force_win_on.png"
        );
        winButton.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(winButton);
        const loseButton = new Phaser.Button(
          this.game,
          920,
          75,
          "texture_atlas_0"
        );
        loseButton.anchor.set(1.0, 0.5);
        loseButton.inputEnabled = true;
        loseButton.events.onInputDown.add(this.onClickForceLose, this);
        loseButton.setFrames(
          "btn_force_lose_on.png",
          "btn_force_lose_off.png",
          "btn_force_lose_on.png"
        );
        loseButton.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(loseButton);
        const resetButton = new Phaser.Button(
          this.game,
          150,
          40,
          "texture_atlas_0"
        );
        resetButton.anchor.set(1.0, 0.5);
        resetButton.inputEnabled = true;
        resetButton.events.onInputDown.add(this.onClickForceReset, this);
        resetButton.setFrames(
          "btn_menu_on.png",
          "btn_menu_off.png",
          "btn_menu_on.png"
        );
        resetButton.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(resetButton);
      } else if (
        MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE
      ) {
        this.chatButton = new Phaser.Button(
          this.game,
          MiniBillar.GameVars.gameWidth / 2 -
            40 * MiniBillar.GameVars.scaleXMult,
          18,
          "texture_atlas_1",
          this.onClickChat,
          this
        );
        this.chatButton.setFrames(
          "btn_chat_on.png",
          "btn_chat_off.png",
          "btn_chat_on.png"
        );
        this.chatButton.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.chatButton.anchor.set(0.5);
        if (this.game.device.touch) {
          this.chatButton.onInputDown.add(
            function () {
              MiniBillar.GameVars.GUIButtonDown = true;
              this.chatButton.scale.set(
                this.chatButton.scale.x * 1.1,
                this.chatButton.scale.y * 1.1
              );
            },
            this,
            5
          );
        }
        this.chatButton.onInputOver.add(function () {
          this.chatButton.scale.set(
            this.chatButton.scale.x * 1.1,
            this.chatButton.scale.y * 1.1
          );
        }, this);
        this.chatButton.onInputOut.add(function () {
          this.chatButton.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
        }, this);
        this.chatButton.forceOut = true;
        this.add(this.chatButton);
        if (
          MiniBillar.GameConstants.SHOW_PVBOT_CHEAT_BUTTONS &&
          MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
        ) {
          MiniBillar.GameVars.laserGuideActive = false;
          MiniBillar.GameVars.sabotageBot = false;
          const superGuideButton = new Phaser.Button(
            this.game,
            920,
            25,
            "texture_atlas_0"
          );
          superGuideButton.anchor.set(1.0, 0.5);
          superGuideButton.inputEnabled = true;
          superGuideButton.events.onInputDown.add(
            this.onClickActivateSuperGuide,
            this
          );
          superGuideButton.setFrames(
            "btn_laserGuide_pressed.png",
            "btn_laserGuide.png",
            "btn_laserGuide_pressed.png"
          );
          superGuideButton.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
          this.add(superGuideButton);
          const sabotageBotButton = new Phaser.Button(
            this.game,
            920,
            75,
            "texture_atlas_0"
          );
          sabotageBotButton.anchor.set(1.0, 0.5);
          sabotageBotButton.inputEnabled = true;
          sabotageBotButton.events.onInputDown.add(
            this.onClickActivateSabotageBot,
            this
          );
          sabotageBotButton.setFrames(
            "btn_bot_sabotage_pressed.png",
            "btn_bot_sabotage.png",
            "btn_bot_sabotage_pressed.png"
          );
          sabotageBotButton.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
          this.add(sabotageBotButton);
        }
      }
      const pauseButton = new Phaser.Button(
        this.game,
        38 * MiniBillar.GameVars.scaleXMult,
        38 * MiniBillar.GameVars.scaleYMult,
        "texture_atlas_1"
      );
      pauseButton.inputEnabled = true;
      pauseButton.anchor.set(0.5);
      pauseButton.events.onInputUp.add(this.onClickPause, this);
      if (this.game.device.touch) {
        pauseButton.onInputDown.add(
          function () {
            MiniBillar.GameVars.GUIButtonDown = true;
            pauseButton.scale.set(
              pauseButton.scale.x * 1.1,
              pauseButton.scale.y * 1.1
            );
          },
          this,
          5
        );
      }
      pauseButton.onInputOver.add(function () {
        pauseButton.scale.set(
          pauseButton.scale.x * 1.1,
          pauseButton.scale.y * 1.1
        );
      }, this);
      pauseButton.onInputOut.add(function () {
        pauseButton.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
      }, this);
      pauseButton.setFrames(
        "btn_pause_pressed.png",
        "btn_pause.png",
        "btn_pause_pressed.png"
      );
      pauseButton.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(pauseButton);
      this.cueBallSpinButton = new MiniBillar.CueBallSpinButton(this.game);
      this.cueBallSpinButton.x =
        MiniBillar.GameVars.gameWidth - 37 * MiniBillar.GameVars.scaleXMult;
      this.cueBallSpinButton.y = 37 * MiniBillar.GameVars.scaleYMult;
      this.add(this.cueBallSpinButton);
      if (this.game.device.touch) {
        this.forceSettingContainer = new MiniBillar.ForceSettingContainer(
          this.game
        );
        this.add(this.forceSettingContainer);
      } else {
        this.forceSettingContainer = null;
      }
    }
    setRedPointPosition(english, verticalSpin) {
      this.cueBallSpinButton.setRedPointPosition(english, verticalSpin);
    }
    start() {
      if (this.game.device.touch) {
        if (this.forceSettingContainer) {
          if (
            MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE
          ) {
            this.forceSettingContainer.reset();
            this.forceSettingContainer.show();
          } else if (
            MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
          ) {
            this.forceSettingContainer.reset();
            this.forceSettingContainer.show();
          }
        }
      }
      this.checkCueBallButtonValidity();
    }
    newTurn() {
      if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
        this.cueBallSpinButton.enable();
      } else {
        this.cueBallSpinButton.disable();
      }
      if (this.game.device.touch) {
        if (this.forceSettingContainer) {
          if (
            MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE
          ) {
            this.forceSettingContainer.reset();
            this.forceSettingContainer.show();
          } else if (
            MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
          ) {
            this.forceSettingContainer.reset();
            this.forceSettingContainer.show();
          }
        }
      }
      this.checkCueBallButtonValidity();
      MiniBillar.MatchManager.resetSpinCircleLayer();
    }
    disableSpinButton() {
      this.cueBallSpinButton.disable();
    }
    hideChatButton() {
      this.chatButton.visible = false;
    }
    showChatButton() {
      this.chatButton.visible = true;
    }
    checkCueBallButtonValidity() {
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        if (
          MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
        ) {
          this.cueBallSpinButton.enable();
        } else {
          this.cueBallSpinButton.disable();
        }
      } else {
        this.cueBallSpinButton.enable();
      }
    }
    onClickPause(b) {
      b.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      MiniBillar.MatchManager.showPauseLayer();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickForceWin() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.GameVars.playerPoints =
          MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD + 1;
        MiniBillar.MatchManagerSolo.endSoloGame(
          MiniBillar.GameConstants.PLAYER_WIN
        );
      }
    }
    onClickForceLose() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.GameVars.playerPoints = 0;
        MiniBillar.MatchManagerSolo.endSoloGame(
          MiniBillar.GameConstants.PLAYER_LOSE
        );
      }
    }
    onClickForceReset() {
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        MiniBillar.MatchManagerSolo.reset();
      }
    }
    onClickActivateSuperGuide() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      MiniBillar.GameVars.laserGuideActive =
        !MiniBillar.GameVars.laserGuideActive;
      console.log(
        MiniBillar.GameVars.laserGuideActive
          ? "Laser cue guide active"
          : "Laser cue guide inactive"
      );
    }
    onClickActivateSabotageBot() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      MiniBillar.GameVars.sabotageBot = !MiniBillar.GameVars.sabotageBot;
      console.log(
        MiniBillar.GameVars.sabotageBot ? "Bot will fail" : "Bot back to normal"
      );
    }
    onClickChat() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      this.chatButton.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      MiniBillar.PoolState.currentInstance.showChatLayer();
    }
  }
  GUI.CUE_BALL_BUTTON_SCALE = 0.13;
  MiniBillar.GUI = GUI;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class SelectPockets extends Phaser.Group {
    constructor(game) {
      super(game, null, "select-pocket");
      this.canSelect = false;
      this.selectedPocketId = -1;
      this.pockets = [];
      for (let i = 0; i < 6; i++) {
        const x =
          MiniBillar.GameVars.pocketArray[i].position.x *
          MiniBillar.GameConstants.PHYS_SCALE;
        const y =
          MiniBillar.GameVars.pocketArray[i].position.y *
          MiniBillar.GameConstants.PHYS_SCALE;
        let pocket = new Phaser.Image(
          this.game,
          x,
          y,
          "texture_atlas_1",
          "pocket_mark.png"
        );
        pocket.anchor.set(0.5);
        pocket.name = MiniBillar.GameVars.pocketArray[i].id.toString();
        pocket.inputEnabled = true;
        pocket.events.onInputUp.add(this.onPocketDown, this);
        this.add(pocket);
        this.pockets.push(pocket);
      }
      this.visible = false;
    }
    showSelectPockets() {
      if (this.visible && this.alpha !== 0.8) {
        return;
      }
      this.alpha = 1;
      this.hideSelectPockets();
      MiniBillar.GameVars.pocketIdWhereBlackFell = -1;
      MiniBillar.StageContainer.currentInstance.hideCue(
        "Showing select pockets"
      );
      MiniBillar.StageContainer.currentInstance.hideGuide(
        "Showing select pockets"
      );
      this.visible = true;
      this.canSelect = true;
      this.tweens = [];
      for (let i = 0; i < 6; i++) {
        const tween = this.game.add.tween(this.pockets[i]).to(
          {
            alpha: [0, 1],
          },
          2000,
          Phaser.Easing.Linear.None,
          true,
          0,
          -1
        );
        this.tweens.push(tween);
      }
    }
    hideSelectPockets() {
      if (!this.visible) {
        return;
      }
      this.visible = false;
      for (let i = 0; i < 6; i++) {
        this.game.tweens.remove(this.tweens[i]);
        this.pockets[i].alpha = 1;
      }
    }
    setRivalPocket(pocketId) {
      this.setSelectedPocket(pocketId, false);
    }
    resetSelectedPocket() {
      this.selectedPocketId = -1;
    }
    setSelectedPocket(pocketId, showCueAndGuide = true) {
      if (!this.canSelect) {
        return;
      }
      this.canSelect = false;
      if (showCueAndGuide) {
        MiniBillar.StageContainer.currentInstance.showCue("Select pockets set");
        MiniBillar.StageContainer.currentInstance.showGuide(
          "Select pockets set"
        );
      }
      for (let i = 0; i < 6; i++) {
        this.game.tweens.remove(this.tweens[i]);
        if (parseInt(this.pockets[i].name) === pocketId) {
          this.pockets[i].alpha = 0.6;
        } else {
          this.pockets[i].alpha = 0;
        }
      }
      this.selectedPocketId = pocketId;
      MiniBillar.MatchManager.pocketSelected(pocketId);
    }
    onPocketDown(img) {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      const pocketId = parseInt(img.name);
      this.setSelectedPocket(pocketId);
    }
  }
  MiniBillar.SelectPockets = SelectPockets;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class SpinCircleLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "spin-circle");
      SpinCircleLayer.currentInstance = this;
      SpinCircleLayer.discardClick = false;
      this.canMove = false;
      let transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.8;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputUp.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const ballContainer = new Phaser.Group(this.game);
      ballContainer.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      ballContainer.x = MiniBillar.GameVars.gameWidth / 2;
      ballContainer.y = MiniBillar.GameVars.gameHeight / 2;
      this.add(ballContainer);
      const circle = new Phaser.Image(
        this.game,
        0,
        0,
        "texture_atlas_1",
        "cue_ball.png"
      );
      circle.anchor.set(0.5);
      circle.inputEnabled = true;
      circle.input.pixelPerfectClick = true;
      circle.input.pixelPerfectAlpha = 0.5;
      circle.events.onInputDown.add(this.onDownCircle, this);
      circle.events.onInputUp.add(this.onUpCircle, this);
      circle.events.onInputOut.add(this.onUpCircle, this);
      ballContainer.add(circle);
      this.redDot = new Phaser.Graphics(
        this.game,
        MiniBillar.GameVars.english,
        MiniBillar.GameVars.verticalSpin
      );
      this.redDot.beginFill(0xf1004f);
      this.redDot.drawCircle(0, 0, 40);
      ballContainer.add(this.redDot);
      this.alpha = 0;
      this.visible = false;
      this.game.add.tween(this).to(
        {
          alpha: 1,
        },
        400,
        Phaser.Easing.Cubic.Out,
        true
      );
    }
    show() {
      this.visible = true;
      this.game.add.tween(this).to(
        {
          alpha: 1,
        },
        400,
        Phaser.Easing.Cubic.Out,
        true
      );
    }
    hide() {
      SpinCircleLayer.discardClick = false;
      this.visible = false;
      this.alpha = 0;
    }
    reset() {
      this.redDot.scale.set(1, 1);
      this.redDot.position.set(0, 0);
    }
    destroy() {
      SpinCircleLayer.currentInstance = null;
      SpinCircleLayer.discardClick = false;
      super.destroy();
    }
    update() {
      super.update();
      if (this.canMove) {
        this.redDot.scale.set(3, 3);
        const x =
          (this.game.input.activePointer.x -
            MiniBillar.GameVars.gameWidth / 2) *
          MiniBillar.GameVars.scaleXMultInverse;
        const y =
          (this.game.input.activePointer.y -
            MiniBillar.GameVars.gameHeight / 2) *
          MiniBillar.GameVars.scaleYMultInverse;
        const d = Math.sqrt(x * x + y * y);
        if (d < SpinCircleLayer.SPIN_CIRCLE_RADIUS) {
          this.redDot.position.set(x, y);
        }
      }
    }
    onDownTransparentLayer() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      const english =
        Math.floor(
          (1000 * this.redDot.x) / SpinCircleLayer.SPIN_CIRCLE_RADIUS
        ) / 1000;
      const verticalSpin =
        -Math.floor(
          (1000 * this.redDot.y) / SpinCircleLayer.SPIN_CIRCLE_RADIUS
        ) / 1000;
      MiniBillar.MatchManager.hideSpinCircleLayer(english, verticalSpin);
    }
    onDownCircle() {
      this.canMove = true;
    }
    onUpCircle() {
      this.canMove = false;
      this.redDot.scale.set(1, 1);
    }
  }
  SpinCircleLayer.currentInstance = null;
  SpinCircleLayer.discardClick = false;
  SpinCircleLayer.SPIN_CIRCLE_RADIUS = 160;
  MiniBillar.SpinCircleLayer = SpinCircleLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class AvatarBubble extends Phaser.Group {
    constructor(game, imageName, x, y, useTimer) {
      super(game, null, "avatar-bubble");
      this.game = game;
      this.x = x;
      this.y = y;
      this.useTimer = useTimer;
      const bubbleRadiusOuter = 81;
      const bubbleRadiusInner = 74;
      const bubbleBorder = new Phaser.Graphics(this.game);
      bubbleBorder.beginFill(0xd3f1f7);
      bubbleBorder.drawCircle(0, 0, bubbleRadiusOuter);
      this.add(bubbleBorder);
      if (this.useTimer) {
        this.timerSprite = new Phaser.Sprite(
          this.game,
          0,
          0,
          "texture_atlas_1",
          "timer_60.png"
        );
        this.timerSprite.scale.set(bubbleRadiusOuter / this.timerSprite.width);
        this.timerSprite.anchor.set(0.5);
        this.add(this.timerSprite);
      }
      this.avatarImage = new Phaser.Image(
        this.game,
        0,
        0,
        "texture_atlas_5",
        imageName + ".png"
      );
      this.avatarImage.scale.set(bubbleRadiusInner / this.avatarImage.width);
      this.avatarImage.anchor.set(0.5, 0.325);
      this.avatarImage.scale.set(0.425);
      this.add(this.avatarImage);
      const mask = new Phaser.Graphics(this.game);
      mask.beginFill(0xffffff);
      mask.drawCircle(0, 0, bubbleRadiusInner);
      this.add(mask);
      this.avatarImage.mask = mask;
    }
    hideTimer(skipTween = false, timeout) {
      if (!this.useTimer || !this.timerSprite.visible) {
        return;
      }
      if (skipTween) {
        this.timerSprite.visible = false;
      } else {
        if (timeout) {
          this.timerSprite.frameName = "timer_1.png";
        }
        this.game.add
          .tween(this.timerSprite.scale)
          .to(
            {
              x: 1.2,
              y: 1.2,
            },
            150,
            Phaser.Easing.Quadratic.Out,
            true
          )
          .onComplete.add(function () {
            this.game.add
              .tween(this.timerSprite.scale)
              .to(
                {
                  x: 0.5,
                  y: 0.5,
                },
                750,
                Phaser.Easing.Quadratic.In,
                true
              )
              .onComplete.add(function () {
                this.timerSprite.visible = false;
              }, this);
          }, this);
      }
    }
    showTimer() {
      if (!this.useTimer) {
        return;
      }
      this.timerSprite.scale.set(1);
      this.timerSprite.visible = true;
    }
    setTimerProgress(frame) {
      if (!this.useTimer) {
        return;
      }
      frame = Phaser.Math.clamp(frame, 1, 60);
      this.timerSprite.frameName = "timer_" + frame + ".png";
    }
    setFrameName(frameName) {
      this.avatarImage.frameName = frameName;
    }
    setAlpha(alpha) {
      this.avatarImage.alpha = alpha;
    }
  }
  MiniBillar.AvatarBubble = AvatarBubble;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class EmoticonBalloon extends Phaser.Group {
    constructor(game, isPlayer) {
      super(game, null, "emoticon-balloon");
      this.isPlayer = isPlayer;
      this.visible = false;
      this.scale.set(0);
      const balloon = new Phaser.Image(
        this.game,
        0,
        0,
        "texture_atlas_1",
        "emoticon_balloon.png"
      );
      balloon.anchor.set(0.5);
      if (!isPlayer) {
        balloon.scale.x = -1;
      }
      this.add(balloon);
      this.emoticon = new Phaser.Image(
        this.game,
        balloon.x,
        balloon.y + 4,
        "texture_atlas_5"
      );
      this.emoticon.anchor.set(0.5);
      this.add(this.emoticon);
    }
    update() {
      super.update();
      if (this.visible) {
        this.f++;
        if (this.f === 300) {
          this.hide();
        }
      }
    }
    showEmoticon(emoticonID) {
      emoticonID = emoticonID || 1;
      this.f = 0;
      this.emoticon.frameName = "emoticon_" + emoticonID + ".png";
      this.visible = true;
      this.scale.set(0);
      let delay = this.isPlayer ? 250 : 0;
      this.game.add.tween(this.scale).to(
        {
          x: 1,
          y: 1,
        },
        400,
        Phaser.Easing.Elastic.Out,
        true,
        delay
      );
    }
    hide() {
      this.game.add
        .tween(this.scale)
        .to(
          {
            x: 0,
            y: 0,
          },
          750,
          Phaser.Easing.Elastic.In,
          true
        )
        .onComplete.add(function () {
          this.visible = false;
          if (this.isPlayer) {
            MiniBillar.PoolState.currentInstance.onPlayerEmoticonShown();
          }
        }, this);
    }
  }
  MiniBillar.EmoticonBalloon = EmoticonBalloon;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class HUD extends Phaser.Group {
    constructor(game) {
      super(game, null, "hud");
      this.x = MiniBillar.GameVars.gameWidth / 2;
      this.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.sumPoints = false;
      this.counter = 0;
      this.timerSXOffset = 14;
      this.sidesAssigned = false;
      this.sumTime = false;
      this.counterTime = 0;
      this.updateNonSOLOClock = false;
      const hudBg = new Phaser.Image(
        this.game,
        0,
        0,
        "texture_atlas_1",
        "hudBg.png"
      );
      hudBg.anchor.set(0.5, 1);
      hudBg.angle = 180;
      this.add(hudBg);
      this.matchDataContainer = this.game.add.group();
      this.add(this.matchDataContainer);
      this.matchDataContainer.y = -20;
      this.pocketedBalls = [];
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        this.createSoloModeHud();
        this.superText = new Phaser.Image(
          this.game,
          0,
          MiniBillar.GameVars.gameHeight * 0.4,
          "texture_atlas_1",
          "superText.png"
        );
        this.superText.anchor.set(0.5);
        this.superText.scale.set(0);
        this.superText.alpha = 0;
        this.add(this.superText);
        this.comboText = new Phaser.Image(
          this.game,
          0,
          MiniBillar.GameVars.gameHeight * 0.4,
          "texture_atlas_1",
          "comboText.png"
        );
        this.comboText.anchor.set(0.5);
        this.comboText.scale.set(0);
        this.comboText.alpha = 0;
        this.add(this.comboText);
        this.comboTextTween1 = null;
        this.comboTextTween2 = null;
      } else {
        this.createPlayersInfoBar(
          MiniBillar.GameVars.gameData.playerData,
          MiniBillar.GameVars.adversaryData
        );
        this.vs = new Phaser.Image(
          this.game,
          0,
          65,
          "texture_atlas_1",
          "vs.png"
        );
        this.vs.anchor.set(0.5);
        this.matchDataContainer.add(this.vs);
        this.createPocketedBallsSetsNonSOLO();
        this.createEmoticonBalloons();
      }
    }
    start() {
      if (
        MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE &&
        MiniBillar.GameVars.firstShot
      ) {
        this.animatePlayerDataOnStart();
        this.updateNonSOLOClock = true;
        this.turnStartTime = new Date();
      }
    }
    update() {
      super.update();
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        this.updateSoloScore();
      } else {
        if (this.updateNonSOLOClock) {
          if (MiniBillar.GameVars.gameOver) {
            this.updateNonSOLOClock = false;
          }
          const currentTime = new Date();
          const timeDifference =
            this.turnStartTime.getTime() - currentTime.getTime();
          const halfSecondsPassedDuringTurn = Math.floor(
            Math.abs(timeDifference / 500)
          );
          if (
            MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
          ) {
            this.playerAvatarBubble.setTimerProgress(
              MiniBillar.GameVars.timerPVP * 2 - halfSecondsPassedDuringTurn
            );
          } else {
            this.adversaryAvatarBubble.setTimerProgress(
              MiniBillar.GameVars.timerPVP * 2 - halfSecondsPassedDuringTurn
            );
          }
          if (
            MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
          ) {
            if (MiniBillar.GameVars.timerPVP * 1000 + timeDifference < 0) {
              MiniBillar.RulesManager.timeOut();
            }
          }
        }
      }
    }
    newTurn() {
      for (let ballId of this.pocketedBalls) {
        this.updateBallSet(ballId);
      }
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        this.updateNonSOLOClock = true;
        this.turnStartTime = new Date();
      }
      if (this.sidesAssigned) {
        this.pocketedBalls = [];
      }
    }
    ballPocketed(id) {
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        this.sumPoints = true;
        if (id !== 0) {
          this.sumTime = true;
        }
      } else if (id === 8 || id === 0) {
        return;
      }
      this.pocketedBalls.push(id);
      this.updateBallSet(id);
    }
    assignSidesForNonSOLO(leftSideType) {
      this.populateBallSetNonSOLO(
        leftSideType !== MiniBillar.GameConstants.BALL_TYPE_SOLID
      );
    }
    focusOnActivePortrait(startingGame) {
      const playerTurn =
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER;
      this.playerAvatarBubble.setAlpha(playerTurn ? 1 : 0.45);
      this.adversaryAvatarBubble.setAlpha(playerTurn ? 0.45 : 1);
      if (playerTurn) {
        this.playerAvatarBubble.setTimerProgress(60);
        this.adversaryAvatarBubble.hideTimer(startingGame, true);
        this.playerAvatarBubble.showTimer();
      } else {
        this.adversaryAvatarBubble.setTimerProgress(60);
        this.playerAvatarBubble.hideTimer(startingGame, true);
        this.adversaryAvatarBubble.showTimer();
      }
    }
    hideNonSOLOTimers() {
      this.updateNonSOLOClock = false;
      if (this.playerAvatarBubble.visible) {
        this.playerAvatarBubble.hideTimer(false, false);
      }
      if (this.adversaryAvatarBubble.visible) {
        this.adversaryAvatarBubble.hideTimer(false, false);
      }
    }
    updateBallsHUD() {
      this.ballPocketed();
    }
    updateSoloTimer() {
      if (!this.sumTime) {
        this.timer.text = Math.max(MiniBillar.GameVars.timerSolo, 0) + "";
        this.updateTimerSLabel();
        if (MiniBillar.GameVars.timerSolo <= 20) {
          MiniBillar.AudioManager.playEffect(
            MiniBillar.AudioManager.TIME_RUNNING_OUT
          );
        } else {
          MiniBillar.AudioManager.stopEffect(
            MiniBillar.AudioManager.TIME_RUNNING_OUT
          );
        }
      }
    }
    stopClock() {
      if (this.updateNonSOLOClock) {
        this.updateNonSOLOClock = false;
      }
    }
    showEmoticon(emoticonID, isPlayer) {
      if (isPlayer) {
        this.playerEmoticonBalloon.showEmoticon(emoticonID);
      } else {
        this.adversaryEmoticonBalloon.showEmoticon(emoticonID);
      }
    }
    showComboEffect(delay = 0) {
      this.comboTextTween1 = this.game.add.tween(this.comboText.scale).to(
        {
          x: 1,
          y: 1,
        },
        600,
        Phaser.Easing.Elastic.Out,
        true,
        delay
      );
      this.comboTextTween1.onStart.add(function () {
        this.createExplosionArray(this.comboText.x, this.comboText.y + 50, 10);
      }, this);
      this.game.add
        .tween(this.comboText)
        .to(
          {
            alpha: 1,
          },
          400,
          Phaser.Easing.Cubic.Out,
          true
        )
        .onComplete.add(function () {
          this.comboTextTween2 = this.game.add
            .tween(this.comboText)
            .to(
              {
                alpha: 0,
              },
              400,
              Phaser.Easing.Cubic.Out,
              true,
              1800
            )
            .onComplete.add(function () {
              this.comboText.scale.set(0);
            }, this);
        }, this);
    }
    showSuperComboEffect(delay) {
      this.game.add.tween(this.superText.scale).to(
        {
          x: 1,
          y: 1,
        },
        600,
        Phaser.Easing.Elastic.Out,
        true,
        delay
      );
      if (this.comboTextTween1) {
        this.comboTextTween1.pendingDelete = true;
      }
      if (this.comboTextTween2) {
        this.comboTextTween2.pendingDelete = true;
      }
      let tween = this.game.add.tween(this.superText);
      tween.to(
        {
          alpha: 1,
        },
        400,
        Phaser.Easing.Cubic.Out,
        true,
        delay
      );
      tween.onStart.add(function () {
        this.showComboEffect(600);
        this.createExplosionArray(this.superText.x, this.superText.y - 30, 10);
      }, this);
      tween.onComplete.add(function () {
        this.game.add
          .tween(this.superText)
          .to(
            {
              alpha: 0,
            },
            400,
            Phaser.Easing.Cubic.Out,
            true,
            800
          )
          .onComplete.add(function () {
            this.superText.scale.set(0);
          }, this);
      }, this);
    }
    createExplosionArray(x, y, explosionCount) {
      const xDelta = 20;
      let startX = -(xDelta * (explosionCount * 0.5));
      for (let i = 0; i < explosionCount; i++) {
        const sparkleSprite = new Phaser.Sprite(
          this.game,
          startX + i * xDelta,
          y,
          "texture_atlas_1"
        );
        sparkleSprite.anchor.set(0.5);
        sparkleSprite.angle = (360 / explosionCount) * i;
        const sparkleFrames = MiniBillar.Utils.createAnimFramesArr(
          "sparkle_effect",
          14,
          false,
          0,
          15
        );
        sparkleSprite.animations
          .add("sparkle", sparkleFrames)
          .play(24, false, true);
        this.add(sparkleSprite);
        sparkleSprite.sendToBack();
      }
    }
    updateBallSet(ballId) {
      for (let entry of this.ballsSet) {
        if (entry.frameName === "ball_icon_" + ballId + ".png") {
          entry.frameName = "ball_icon_0.png";
        }
      }
    }
    updateSoloScore() {
      if (this.sumPoints) {
        let num = parseInt(this.points.text.replace(/,/g, ""));
        if (MiniBillar.GameVars.playerPoints > 999999) {
          this.points.setStyle(
            {
              font: "28px Oswald-DemiBold",
            },
            true
          );
          if (MiniBillar.GameVars.playerPoints > 9999999) {
            this.points.setStyle(
              {
                font: "24px Oswald-DemiBold",
              },
              true
            );
          }
        }
        if (num < MiniBillar.GameVars.playerPoints) {
          num++;
          this.points.text = MiniBillar.Utils.validNumber(num) + " pts";
          this.points.fill = "#1CCE68";
          if (num > MiniBillar.GameVars.gameData.statistics.solo.highScore) {
            MiniBillar.GameVars.gameData.statistics.solo.highScore = num;
            this.highscoreLayer.text = MiniBillar.Utils.validNumber(
              MiniBillar.GameVars.gameData.statistics.solo.highScore
            );
          }
        } else if (num > MiniBillar.GameVars.playerPoints) {
          if (this.counter === 3) {
            num--;
            this.points.text = MiniBillar.Utils.validNumber(num) + " pts";
            this.points.fill = "#FA2E63";
            if (num > MiniBillar.GameVars.gameData.statistics.solo.highScore) {
              MiniBillar.GameVars.gameData.statistics.solo.highScore = num;
              this.highscoreLayer.text = MiniBillar.Utils.validNumber(
                MiniBillar.GameVars.gameData.statistics.solo.highScore
              );
            }
            this.counter = 0;
          } else {
            this.counter++;
          }
        } else {
          this.counter = 0;
          this.sumPoints = false;
          this.points.fill = "#E5FFFF";
        }
      }
      if (this.sumTime) {
        let num = parseInt(this.timer.text);
        if (num < MiniBillar.GameVars.timerSolo) {
          if (this.counterTime === 3) {
            num++;
            this.timer.text = num + "";
            this.updateTimerSLabel();
            this.counterTime = 0;
          } else {
            this.counterTime++;
          }
        } else {
          this.sumTime = false;
        }
      }
    }
    updateTimerSLabel() {
      if (MiniBillar.GameVars.timerSolo > 999) {
        this.timerS.x = this.timer.x + this.timerSXOffset * 4;
      } else if (MiniBillar.GameVars.timerSolo > 99) {
        this.timerS.x = this.timer.x + this.timerSXOffset * 3;
      } else if (MiniBillar.GameVars.timerSolo > 9) {
        this.timerS.x = this.timer.x + this.timerSXOffset * 2;
      } else {
        this.timerS.x = this.timer.x + this.timerSXOffset;
      }
    }
    createSoloModeHud() {
      this.createPocketedBallsSetsSolo();
      this.populateBallSetSolo();
      const nameLine = new Phaser.Image(
        this.game,
        -276,
        54,
        "texture_atlas_1",
        "name_line.png"
      );
      nameLine.anchor.set(0, 0.5);
      this.matchDataContainer.add(nameLine);
      const playerName = new Phaser.Text(
        this.game,
        -261,
        58,
        MiniBillar.GameVars.gameData.playerData.nick,
        {
          font: "18px Oswald-Medium",
          fontWeight: "400",
          fill: "#E5FFFF",
        }
      );
      playerName.anchor.set(0, 1);
      this.matchDataContainer.add(playerName);
      const avatarBubble = new MiniBillar.AvatarBubble(
        this.game,
        MiniBillar.GameVars.gameData.playerData.avatar,
        -310,
        65,
        false
      );
      this.matchDataContainer.add(avatarBubble);
      this.timer = new Phaser.Text(
        this.game,
        0,
        76,
        MiniBillar.GameVars.timerSolo.toString(),
        {
          font: "44px Oswald-DemiBold",
          fontWeight: "400",
          fill: "#E5FFFF",
        }
      );
      this.timer.anchor.set(0.5, 1);
      this.matchDataContainer.add(this.timer);
      this.timerS = new Phaser.Text(this.game, 0, this.timer.y - 5, "s", {
        font: "24px Oswald-DemiBold",
        fontWeight: "400",
        fill: "#E5FFFF",
      });
      this.timerS.anchor.set(0, 1);
      this.matchDataContainer.add(this.timerS);
      this.updateTimerSLabel();
      this.points = new Phaser.Text(
        this.game,
        340,
        82,
        MiniBillar.Utils.validNumber(MiniBillar.GameVars.playerPoints) + " pts",
        {
          font: "28px Oswald-DemiBold",
          fontWeight: "400",
          fill: "#E5FFFF",
        }
      );
      this.points.anchor.set(1, 0.5);
      this.matchDataContainer.add(this.points);
      const highScoreLabel = new Phaser.Text(this.game, 275, 54, "HIGHSCORE:", {
        font: "21px Oswald-Medium",
        fontWeight: "400",
        fill: "#E5FFFF",
      });
      highScoreLabel.anchor.set(1);
      this.matchDataContainer.add(highScoreLabel);
      this.highscoreLayer = new Phaser.Text(
        this.game,
        340,
        54,
        MiniBillar.Utils.validNumber(
          MiniBillar.GameVars.gameData.statistics.solo.highScore
        ),
        {
          font: "21px Oswald-Medium",
          fontWeight: "400",
          fill: "#E5FFFF",
        }
      );
      this.highscoreLayer.anchor.set(1);
      this.matchDataContainer.add(this.highscoreLayer);
    }
    createPlayersInfoBar(playerData, adversaryData) {
      this.playerNameLabel = new Phaser.Text(
        this.game,
        -125,
        39,
        playerData.nick,
        {
          font: "18px Oswald-Medium",
          fontWeight: "400",
          fill: "#E5FFFF",
        }
      );
      this.playerNameLabel.anchor.set(1, 0.5);
      this.matchDataContainer.add(this.playerNameLabel);
      const playerNameLine = new Phaser.Image(
        this.game,
        -110,
        52,
        "texture_atlas_1",
        "name_line.png"
      );
      playerNameLine.anchor.set(0, 0.5);
      playerNameLine.scale.x *= -1;
      this.matchDataContainer.add(playerNameLine);
      this.playerAvatarBubble = new MiniBillar.AvatarBubble(
        this.game,
        playerData.avatar,
        -80,
        63,
        true
      );
      this.matchDataContainer.add(this.playerAvatarBubble);
      const currentCuePlayer = new Phaser.Image(
        this.game,
        -440,
        63,
        "texture_atlas_5",
        MiniBillar.GameVars.gameData.playerData.equipedCue + "_sprite_0.png"
      );
      currentCuePlayer.scale.set(0.8, 0.8);
      currentCuePlayer.anchor.set(1, 0.5);
      currentCuePlayer.angle = 180;
      this.matchDataContainer.add(currentCuePlayer);
      const cueMaskPlayer = new Phaser.Graphics(this.game);
      cueMaskPlayer.beginFill(0xffffff);
      cueMaskPlayer.drawRect(-355, 0, -100, 200);
      this.add(cueMaskPlayer);
      currentCuePlayer.mask = cueMaskPlayer;
      const adversaryName = adversaryData.nick;
      this.adversaryNameLabel = new Phaser.Text(
        this.game,
        125,
        39,
        adversaryName,
        {
          font: "18px Oswald-Medium",
          fontWeight: "400",
          fill: "#E5FFFF",
          align: "center",
        }
      );
      this.adversaryNameLabel.anchor.set(0, 0.5);
      this.matchDataContainer.add(this.adversaryNameLabel);
      const adversaryNameLine = new Phaser.Image(
        this.game,
        110,
        52,
        "texture_atlas_1",
        "name_line.png"
      );
      adversaryNameLine.anchor.set(0, 0.5);
      this.matchDataContainer.add(adversaryNameLine);
      this.adversaryAvatarBubble = new MiniBillar.AvatarBubble(
        this.game,
        adversaryData.avatar,
        80,
        63,
        true
      );
      this.matchDataContainer.add(this.adversaryAvatarBubble);
      const currentCueAdversary = new Phaser.Image(
        this.game,
        440,
        63,
        "texture_atlas_5",
        adversaryData.equipedCue + "_sprite_0.png"
      );
      currentCueAdversary.scale.set(0.8, 0.8);
      currentCueAdversary.anchor.set(1, 0.5);
      this.matchDataContainer.add(currentCueAdversary);
      const cueMaskAdversary = new Phaser.Graphics(this.game);
      cueMaskAdversary.beginFill(0xffffff);
      cueMaskAdversary.drawRect(355, 0, 100, 200);
      this.add(cueMaskAdversary);
      currentCueAdversary.mask = cueMaskAdversary;
    }
    createEmoticonBalloons() {
      this.adversaryEmoticonBalloon = new MiniBillar.EmoticonBalloon(
        this.game,
        false
      );
      this.adversaryEmoticonBalloon.x = 26;
      this.adversaryEmoticonBalloon.y = 112;
      this.matchDataContainer.add(this.adversaryEmoticonBalloon);
      this.playerEmoticonBalloon = new MiniBillar.EmoticonBalloon(
        this.game,
        true
      );
      this.playerEmoticonBalloon.x = -26;
      this.playerEmoticonBalloon.y = 112;
      this.matchDataContainer.add(this.playerEmoticonBalloon);
    }
    createPocketedBallsSetsSolo() {
      this.ballsSet = [];
      let x = -250;
      for (let i = 0; i < 15; i++) {
        let ballSocket = new Phaser.Image(
          this.game,
          x,
          80,
          "texture_atlas_1",
          "ball_icon_0.png"
        );
        ballSocket.anchor.set(0.5);
        this.matchDataContainer.add(ballSocket);
        this.ballsSet.push(ballSocket);
        x += 30;
      }
    }
    createPocketedBallsSetsNonSOLO() {
      this.ballsSet = [];
      const distanceFromCenterX = 327;
      let x = -distanceFromCenterX;
      const distBetweenBalls = 32;
      for (let i = 0; i < 15; i++) {
        if (i === 7) {
          x *= -1;
        } else {
          let ballSocket = new Phaser.Image(
            this.game,
            x,
            74,
            "texture_atlas_1",
            "ball_icon_0.png"
          );
          ballSocket.anchor.set(0.5);
          this.matchDataContainer.add(ballSocket);
          this.ballsSet.push(ballSocket);
        }
        x += distBetweenBalls;
      }
    }
    animatePlayerDataOnStart() {
      this.playerNameLabel.scale.set(0);
      this.playerNameLabel.alpha = 0;
      this.game.add.tween(this.playerNameLabel.scale).to(
        {
          y: 1,
          x: 1,
        },
        300,
        Phaser.Easing.Cubic.Out,
        true,
        500
      );
      this.game.add.tween(this.playerNameLabel).to(
        {
          alpha: 1,
        },
        300,
        Phaser.Easing.Cubic.Out,
        true,
        500
      );
      this.vs.scale.y = 0;
      this.game.add.tween(this.vs.scale).to(
        {
          y: 1,
        },
        300,
        Phaser.Easing.Elastic.Out,
        true,
        1300
      );
      this.adversaryNameLabel.scale.set(0);
      this.adversaryNameLabel.alpha = 0;
      this.game.add.tween(this.adversaryNameLabel.scale).to(
        {
          y: 1,
          x: 1,
        },
        300,
        Phaser.Easing.Cubic.Out,
        true,
        2100
      );
      this.game.add.tween(this.adversaryNameLabel).to(
        {
          alpha: 1,
        },
        300,
        Phaser.Easing.Cubic.Out,
        true,
        2100
      );
    }
    populateBallSetNonSOLO(sidesInverted) {
      this.sidesAssigned = true;
      let imageId = sidesInverted ? 9 : 1;
      for (let i = 0; i < 14; i++) {
        this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
        if (i === 6) {
          if (sidesInverted) {
            imageId = 0;
          } else {
            imageId++;
          }
        }
        imageId++;
      }
    }
    populateBallSetSolo() {
      let imageId = 1;
      for (let i = 0; i < 15; i++) {
        this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
        imageId++;
      }
    }
  }
  MiniBillar.HUD = HUD;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class AdversaryLeftLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "adversary-left-layer");
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.75;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const text = new Phaser.Text(
        this.game,
        MiniBillar.GameVars.gameWidth * 0.5,
        350,
        "ADVERSARY CONNECTION LOST",
        {
          font: "60px Oswald-DemiBold",
          fontWeight: "600",
          fill: "#EB3359",
        }
      );
      text.stroke = "#673952";
      text.strokeThickness = 5;
      text.anchor.set(0.5);
      this.add(text);
      this.showButtonsTimer = 1;
    }
    update() {
      if (!this.buttonsCreated) {
        if (this.showButtonsTimer < 0) {
          this.buttonsCreated = true;
          const buttonHome = new Phaser.Button(
            this.game,
            MiniBillar.GameVars.gameWidth / 2 -
              120 * MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.gameHeight / 2 + 275,
            "texture_atlas_1",
            this.onClickHome,
            this
          );
          buttonHome.setFrames(
            "btn_close_pressed.png",
            "btn_close.png",
            "btn_close_pressed.png",
            "btn_close.png"
          );
          buttonHome.anchor.set(0.5);
          if (this.game.device.touch) {
            buttonHome.onInputDown.add(function () {
              buttonHome.scale.set(
                buttonHome.scale.x * 1.1,
                buttonHome.scale.y * 1.1
              );
            }, this);
          }
          buttonHome.onInputOver.add(function () {
            buttonHome.scale.set(
              buttonHome.scale.x * 1.1,
              buttonHome.scale.y * 1.1
            );
          }, this);
          buttonHome.onInputOut.add(function () {
            buttonHome.scale.set(1, 1);
          }, this);
          buttonHome.forceOut = true;
          buttonHome.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
          this.add(buttonHome);
          const buttonNewRival = new Phaser.Button(
            this.game,
            MiniBillar.GameVars.gameWidth / 2 +
              50 * MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.gameHeight / 2 + 275,
            "texture_atlas_1",
            this.onClickNewRival,
            this
          );
          buttonNewRival.setFrames(
            "btn_new_rival_pressed.png",
            "btn_new_rival.png",
            "btn_new_rival_pressed.png",
            "btn_new_rival.png"
          );
          buttonNewRival.anchor.set(0.5);
          if (this.game.device.touch) {
            buttonNewRival.onInputDown.add(function () {
              buttonNewRival.scale.set(
                buttonNewRival.scale.x * 1.1,
                buttonNewRival.scale.y * 1.1
              );
            }, this);
          }
          buttonNewRival.onInputOver.add(function () {
            buttonNewRival.scale.set(
              buttonNewRival.scale.x * 1.1,
              buttonNewRival.scale.y * 1.1
            );
          }, this);
          buttonNewRival.onInputOut.add(function () {
            buttonNewRival.scale.set(
              MiniBillar.GameVars.scaleXMult,
              MiniBillar.GameVars.scaleYMult
            );
          }, this);
          buttonNewRival.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
          this.add(buttonNewRival);
        } else {
          this.showButtonsTimer -= this.game.time.physicsElapsed;
        }
      }
    }
    onClickHome(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideAdversaryLeftLayer();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickNewRival(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideAdversaryLeftLayer();
      MiniBillar.GameVars.goDirectlyToLobby = true;
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onDownTransparentLayer() {}
  }
  MiniBillar.AdversaryLeftLayer = AdversaryLeftLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class ChatLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "chat-layer");
      ChatLayer.currentInstance = this;
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.25;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const menuContainer = new Phaser.Group(this.game);
      menuContainer.x = MiniBillar.GameVars.gameWidth / 2;
      menuContainer.y = 85;
      menuContainer.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(menuContainer);
      const rectangleWithRadius = new Phaser.Graphics(this.game);
      menuContainer.add(rectangleWithRadius);
      const rectWidth = 710;
      const rectHeight = 160;
      const radius = 20;
      const px = -rectWidth / 2;
      const py = -rectHeight / 2;
      rectangleWithRadius.beginFill(0x1d2836, 0.8);
      rectangleWithRadius.drawRoundedRect(
        px,
        py,
        rectWidth,
        rectHeight,
        radius
      );
      rectangleWithRadius.endFill();
      const rows = 3;
      const cols = 14;
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          let index = cols * j + i + 1;
          if (index <= MiniBillar.GameVars.emoticonsAmount) {
            let delta = 50;
            let x = (i - cols / 2 + 0.5) * delta;
            let y = (j - 1) * delta;
            let emoticonButton = new Phaser.Button(
              this.game,
              x,
              y,
              "texture_atlas_5",
              this.onClickEmoticon,
              this
            );
            emoticonButton.setFrames(
              "emoticon_" + index + "_on.png",
              "emoticon_" + index + ".png",
              "emoticon_" + index + "_on.png"
            );
            emoticonButton.name = index.toString();
            emoticonButton.anchor.set(0.5);
            if (this.game.device.touch) {
              emoticonButton.onInputDown.add(
                function () {
                  MiniBillar.GameVars.GUIButtonDown = true;
                  emoticonButton.scale.set(
                    emoticonButton.scale.x * 1.1,
                    emoticonButton.scale.y * 1.1
                  );
                },
                this,
                5
              );
            }
            emoticonButton.onInputOver.add(function () {
              emoticonButton.scale.set(
                emoticonButton.scale.x * 1.1,
                emoticonButton.scale.y * 1.1
              );
            }, this);
            emoticonButton.onInputOut.add(function () {
              emoticonButton.scale.set(1);
            }, this);
            menuContainer.add(emoticonButton);
          }
        }
      }
    }
    onClickEmoticon(b) {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      b.clearFrames();
      b.scale.set(1);
      MiniBillar.MatchManager.emoticonSelected(parseInt(b.name));
    }
    onDownTransparentLayer() {
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      MiniBillar.PoolState.currentInstance.hideChatLayer();
    }
  }
  MiniBillar.ChatLayer = ChatLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class EndGamePortraitContainer extends Phaser.Group {
    constructor(game, messageImageFilename, isWinner) {
      super(game, null, "end-game-portrait-container");
      const portraitPackY = 280;
      if (isWinner) {
        this.rotateRays = true;
        const rayContainer = this.game.add.group();
        rayContainer.position.set(
          MiniBillar.GameVars.gameWidth / 2,
          portraitPackY
        );
        rayContainer.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(rayContainer);
        this.sendToBack(rayContainer);
        this.portraitRaysImage = new Phaser.Image(
          game,
          0,
          0,
          "texture_atlas_1",
          "rays_win.png"
        );
        this.portraitRaysImage.anchor.set(0.5);
        rayContainer.add(this.portraitRaysImage);
        this.game.add.tween(this.portraitRaysImage.scale).from(
          {
            x: 0.1,
            y: 0.1,
          },
          950,
          Phaser.Easing.Cubic.Out,
          true
        );
      } else {
        this.rotateRays = false;
        this.portraitRaysImage = null;
      }
      this.avatarBubble = new MiniBillar.AvatarBubble(
        this.game,
        MiniBillar.GameVars.gameData.playerData.avatar,
        MiniBillar.GameVars.gameWidth / 2,
        portraitPackY,
        false
      );
      this.avatarBubble.scale.set(
        MiniBillar.GameVars.scaleXMult * 1.78,
        MiniBillar.GameVars.scaleYMult * 1.78
      );
      this.add(this.avatarBubble);
      this.messageImage = new Phaser.Image(
        game,
        MiniBillar.GameVars.gameWidth / 2,
        portraitPackY + 64,
        "texture_atlas_1",
        messageImageFilename
      );
      this.messageImage.anchor.set(0.5);
      this.messageImage.scale.set(MiniBillar.GameVars.scaleXMult, 0.001);
      this.add(this.messageImage);
      this.game.add
        .tween(this.avatarBubble.scale)
        .from(
          {
            x: 0.1,
            y: 0.1,
          },
          800,
          Phaser.Easing.Elastic.Out,
          true
        )
        .onComplete.add(function () {
          this.game.add.tween(this.messageImage.scale).to(
            {
              y: MiniBillar.GameVars.scaleYMult,
            },
            800,
            Phaser.Easing.Elastic.Out,
            true
          );
        }, this);
    }
    update() {
      super.update();
      if (this.rotateRays) {
        this.portraitRaysImage.angle += 0.2;
      }
    }
  }
  MiniBillar.EndGamePortraitContainer = EndGamePortraitContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class LosePVPLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "lose-pvp-layer");
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.6;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(
        game,
        "you_lose.png",
        false
      );
      this.add(endGamePortraitContainer);
      const buttonHome = new Phaser.Button(
        this.game,
        MiniBillar.GameVars.gameWidth / 2 -
          120 * MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.gameHeight / 2 + 275,
        "texture_atlas_1",
        this.onClickHome,
        this
      );
      buttonHome.setFrames(
        "btn_close_pressed.png",
        "btn_close.png",
        "btn_close_pressed.png",
        "btn_close.png"
      );
      buttonHome.anchor.set(0.5);
      if (this.game.device.touch) {
        buttonHome.onInputDown.add(function () {
          buttonHome.scale.set(
            buttonHome.scale.x * 1.1,
            buttonHome.scale.y * 1.1
          );
        }, this);
      }
      buttonHome.onInputOver.add(function () {
        buttonHome.scale.set(
          buttonHome.scale.x * 1.1,
          buttonHome.scale.y * 1.1
        );
      }, this);
      buttonHome.onInputOut.add(function () {
        buttonHome.scale.set(1, 1);
      }, this);
      buttonHome.forceOut = true;
      buttonHome.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(buttonHome);
      const buttonNewRival = new Phaser.Button(
        this.game,
        MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.gameHeight / 2 + 275,
        "texture_atlas_1",
        this.onClickNewRival,
        this
      );
      buttonNewRival.setFrames(
        "btn_new_rival_pressed.png",
        "btn_new_rival.png",
        "btn_new_rival_pressed.png",
        "btn_new_rival.png"
      );
      buttonNewRival.anchor.set(0.5);
      if (this.game.device.touch) {
        buttonNewRival.onInputDown.add(function () {
          buttonNewRival.scale.set(
            buttonNewRival.scale.x * 1.1,
            buttonNewRival.scale.y * 1.1
          );
        }, this);
      }
      buttonNewRival.onInputOver.add(function () {
        buttonNewRival.scale.set(
          buttonNewRival.scale.x * 1.1,
          buttonNewRival.scale.y * 1.1
        );
      }, this);
      buttonNewRival.onInputOut.add(function () {
        buttonNewRival.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
      }, this);
      buttonNewRival.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(buttonNewRival);
      MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.LOSE);
    }
    onClickHome(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideLoseLayer();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickNewRival(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideLoseLayer();
      MiniBillar.GameVars.goDirectlyToLobby = true;
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onDownTransparentLayer() {}
  }
  MiniBillar.LosePVPLayer = LosePVPLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class PauseLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "pause-layer");
      PauseLayer.currentInstance = this;
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.6;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const buttonBack = new Phaser.Button(
        this.game,
        38 * MiniBillar.GameVars.scaleXMult,
        38 * MiniBillar.GameVars.scaleYMult,
        "texture_atlas_1",
        this.onClickExit,
        this
      );
      buttonBack.setFrames(
        "btn_back_on.png",
        "btn_back_off.png",
        "btn_back_on.png",
        "btn_back_off.png"
      );
      buttonBack.forceOut = true;
      buttonBack.anchor.set(0.5);
      if (this.game.device.touch) {
        buttonBack.onInputDown.add(function () {
          buttonBack.scale.set(
            buttonBack.scale.x * 1.1,
            buttonBack.scale.y * 1.1
          );
        }, this);
      }
      buttonBack.onInputOver.add(function () {
        buttonBack.scale.set(
          buttonBack.scale.x * 1.1,
          buttonBack.scale.y * 1.1
        );
      }, this);
      buttonBack.onInputOut.add(function () {
        buttonBack.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
      }, this);
      buttonBack.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(buttonBack);
      let scaledItemsContainer = new Phaser.Group(this.game);
      scaledItemsContainer.x = MiniBillar.GameVars.gameWidth / 2;
      scaledItemsContainer.y = MiniBillar.GameVars.gameHeight / 2;
      scaledItemsContainer.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(scaledItemsContainer);
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        const restartButton = new Phaser.Button(
          this.game,
          0,
          -8,
          "texture_atlas_1",
          this.onClickReset,
          this
        );
        restartButton.setFrames(
          "btn_restart_pressed.png",
          "btn_restart.png",
          "btn_restart_pressed.png",
          "btn_restart.png"
        );
        restartButton.anchor.set(0.5);
        restartButton.scale.set(1);
        if (this.game.device.touch) {
          restartButton.onInputDown.add(function () {
            restartButton.scale.set(
              restartButton.scale.x * 1.1,
              restartButton.scale.y * 1.1
            );
          }, this);
        }
        restartButton.onInputOver.add(function () {
          restartButton.scale.set(
            restartButton.scale.x * 1.1,
            restartButton.scale.y * 1.1
          );
        }, this);
        restartButton.onInputOut.add(function () {
          restartButton.scale.set(1);
        }, this);
        scaledItemsContainer.add(restartButton);
        const soloHomeButton = new Phaser.Button(
          this.game,
          0,
          100,
          "texture_atlas_1",
          this.onClickSoloHome,
          this
        );
        soloHomeButton.setFrames(
          "btn_close_pressed.png",
          "btn_close.png",
          "btn_close_pressed.png",
          "btn_close.png"
        );
        soloHomeButton.anchor.set(0.5);
        if (this.game.device.touch) {
          soloHomeButton.onInputDown.add(function () {
            soloHomeButton.scale.set(
              soloHomeButton.scale.x * 1.1,
              soloHomeButton.scale.y * 1.1
            );
          }, this);
        }
        soloHomeButton.onInputOver.add(function () {
          soloHomeButton.scale.set(
            soloHomeButton.scale.x * 1.1,
            soloHomeButton.scale.y * 1.1
          );
        }, this);
        soloHomeButton.onInputOut.add(function () {
          soloHomeButton.scale.set(1);
        }, this);
        scaledItemsContainer.add(soloHomeButton);
        const rulesText = new Phaser.Text(
          this.game,
          0,
          160,
          MiniBillar.GameConstants.RULES_TEXT,
          {
            font: this.game.device.desktop
              ? "24px Oswald-DemiBold"
              : "34px Oswald-DemiBold",
            fontWeight: "600",
            fill: "#e7f6f8",
            align: "center",
            stroke: "#2f3237",
            strokeThickness: 3,
          }
        );
        rulesText.anchor.set(0.5, 0);
        MiniBillar.Utils.colourRulesText(rulesText);
        scaledItemsContainer.add(rulesText);
      } else {
        const resignButton = new Phaser.Button(
          this.game,
          0,
          -8,
          "texture_atlas_1",
          this.onClickResign,
          this
        );
        resignButton.setFrames(
          "btn_resign_pressed.png",
          "btn_resign.png",
          "btn_resign_pressed.png",
          "btn_resign.png"
        );
        resignButton.anchor.set(0.5);
        resignButton.scale.set(1);
        if (this.game.device.touch) {
          resignButton.onInputDown.add(function () {
            resignButton.scale.set(
              resignButton.scale.x * 1.1,
              resignButton.scale.y * 1.1
            );
          }, this);
        }
        resignButton.onInputOver.add(function () {
          resignButton.scale.set(
            resignButton.scale.x * 1.1,
            resignButton.scale.y * 1.1
          );
        }, this);
        resignButton.onInputOut.add(function () {
          resignButton.scale.set(1);
        }, this);
        scaledItemsContainer.add(resignButton);
      }
      const audioSwitchButton = new MiniBillar.SwitchButton(
        this.game,
        !MiniBillar.GameVars.gameData.musicMuted,
        MiniBillar.SwitchButton.MUSIC
      );
      audioSwitchButton.x = 30;
      audioSwitchButton.y = -100;
      scaledItemsContainer.add(audioSwitchButton);
      const audioLabel = new Phaser.Text(
        this.game,
        -24,
        audioSwitchButton.y + 2,
        "AUDIO",
        {
          font: "24px Oswald-DemiBold",
          fontWeight: "600",
          fill: "#e7f6f8",
          align: "center",
          stroke: "#2f3237",
          strokeThickness: 3,
        }
      );
      audioLabel.anchor.set(1, 0.5);
      scaledItemsContainer.add(audioLabel);
      if (this.game.device.touch) {
        const switchStartingState =
          MiniBillar.GameVars.gameData.powerBarSide ===
          MiniBillar.GameConstants.RIGHT;
        const powerSwitchButton = new MiniBillar.SwitchButton(
          this.game,
          switchStartingState,
          MiniBillar.SwitchButton.POWER
        );
        powerSwitchButton.x = 30;
        powerSwitchButton.y = -160;
        scaledItemsContainer.add(powerSwitchButton);
        const powerTextLeft = "POWER BAR: LEFT";
        const powerTextRight = "POWER BAR: RIGHT";
        this.powerLabel = new Phaser.Text(
          this.game,
          -24,
          powerSwitchButton.y + 2,
          powerTextLeft,
          {
            font: "24px Oswald-DemiBold",
            fontWeight: "600",
            fill: "#e7f6f8",
            align: "center",
            stroke: "#2f3237",
            strokeThickness: 3,
          }
        );
        this.powerLabel.anchor.set(1, 0.5);
        scaledItemsContainer.add(this.powerLabel);
        if (
          MiniBillar.GameVars.gameData.powerBarSide ===
          MiniBillar.GameConstants.RIGHT
        ) {
          this.powerLabel.text = powerTextRight;
        }
        if (
          MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE
        ) {
          scaledItemsContainer.y += 100;
        }
      }
      this.alpha = 0;
      this.game.add.tween(this).to(
        {
          alpha: 1,
        },
        400,
        Phaser.Easing.Cubic.Out,
        true
      );
    }
    changePower() {
      const powerTextLeft = "POWER BAR: LEFT";
      const powerTextRight = "POWER BAR: RIGHT";
      if (
        MiniBillar.GameVars.gameData.powerBarSide ===
        MiniBillar.GameConstants.LEFT
      ) {
        this.powerLabel.text = powerTextLeft;
      } else {
        this.powerLabel.text = powerTextRight;
      }
    }
    destroy() {
      PauseLayer.currentInstance = null;
      super.destroy();
    }
    onClickExit(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hidePauseLayer();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickResign(b) {
      b.clearFrames();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
      MiniBillar.MatchManager.hideNotificationLayer();
      MiniBillar.MatchManager.hidePauseLayer();
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
        if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
          console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
        }
        MiniBillar.MatchManagerPVP.matchOverDueToResignation(
          MiniBillar.GameVars.gameData.playerData.sessionId
        );
      } else if (
        MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
      ) {
        if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
          console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
        }
        MiniBillar.MatchManagerPVBot.matchOverDueToResignation(true);
      }
    }
    onClickReset(b) {
      b.clearFrames();
      MiniBillar.GameVars.paused = false;
      MiniBillar.GameVars.rematch = true;
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.GameManager.enterSoloGame();
      }
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickSoloHome(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hidePauseLayer();
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.MatchManagerSolo.endSoloGame(
          MiniBillar.GameConstants.PLAYER_RESIGNS
        );
      }
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onDownTransparentLayer() {}
  }
  MiniBillar.PauseLayer = PauseLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class RetrySoloLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "retry-solo-layer");
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.6;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      const endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(
        game,
        "game_over.png",
        false
      );
      this.add(endGamePortraitContainer);
      const buttonRestart = new Phaser.Button(
        this.game,
        MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.gameHeight / 2 + 275,
        "texture_atlas_1",
        this.onClickReset,
        this
      );
      buttonRestart.setFrames(
        "btn_restart_pressed.png",
        "btn_restart.png",
        "btn_restart_pressed.png"
      );
      buttonRestart.anchor.set(0.5);
      if (this.game.device.touch) {
        buttonRestart.onInputDown.add(function () {
          buttonRestart.scale.set(
            buttonRestart.scale.x * 1.1,
            buttonRestart.scale.y * 1.1
          );
        }, this);
      }
      buttonRestart.onInputOver.add(function () {
        buttonRestart.scale.set(
          buttonRestart.scale.x * 1.1,
          buttonRestart.scale.y * 1.1
        );
      }, this);
      buttonRestart.onInputOut.add(function () {
        buttonRestart.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
      }, this);
      buttonRestart.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(buttonRestart);
      const buttonHome = new Phaser.Button(
        this.game,
        MiniBillar.GameVars.gameWidth / 2 -
          120 * MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.gameHeight / 2 + 275,
        "texture_atlas_1",
        this.onClickHome,
        this
      );
      buttonHome.setFrames(
        "btn_close_pressed.png",
        "btn_close.png",
        "btn_close_pressed.png"
      );
      buttonHome.anchor.set(0.5);
      if (this.game.device.touch) {
        buttonHome.onInputDown.add(function () {
          buttonHome.scale.set(
            buttonHome.scale.x * 1.1,
            buttonHome.scale.y * 1.1
          );
        }, this);
      }
      buttonHome.onInputOver.add(function () {
        buttonHome.scale.set(
          buttonHome.scale.x * 1.1,
          buttonHome.scale.y * 1.1
        );
      }, this);
      buttonHome.onInputOut.add(function () {
        buttonHome.scale.set(1, 1);
      }, this);
      buttonHome.forceOut = true;
      buttonHome.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(buttonHome);
      MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.LOSE);
    }
    onClickHome(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hidePauseLayer();
      MiniBillar.MatchManager.hideRetryLayer();
      MiniBillar.MatchManagerSolo.endSoloGame(
        MiniBillar.GameConstants.PLAYER_RESIGNS
      );
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickReset(b) {
      b.clearFrames();
      MiniBillar.GameVars.paused = false;
      MiniBillar.GameVars.rematch = true;
      MiniBillar.GameManager.enterSoloGame();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onDownTransparentLayer() {}
  }
  MiniBillar.RetrySoloLayer = RetrySoloLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class VictoryLayer extends Phaser.Group {
    constructor(game) {
      super(game, null, "victory-layer");
      const transparentBackground = new Phaser.Sprite(
        this.game,
        0,
        0,
        this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
      );
      transparentBackground.scale.set(
        MiniBillar.GameVars.gameWidth / 64,
        MiniBillar.GameVars.gameHeight / 64
      );
      transparentBackground.alpha = 0.6;
      transparentBackground.inputEnabled = true;
      transparentBackground.events.onInputDown.add(
        this.onDownTransparentLayer,
        this
      );
      this.add(transparentBackground);
      this.endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(
        game,
        "you_win.png",
        true
      );
      this.add(this.endGamePortraitContainer);
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        this.buttonRestart = new Phaser.Button(
          this.game,
          MiniBillar.GameVars.gameWidth / 2 +
            50 * MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.gameHeight / 2 + 275,
          "texture_atlas_1",
          this.onClickReset,
          this
        );
        this.buttonRestart.setFrames(
          "btn_restart_pressed.png",
          "btn_restart.png",
          "btn_restart_pressed.png"
        );
        this.buttonRestart.anchor.set(0.5);
        if (this.game.device.touch) {
          this.buttonRestart.onInputDown.add(function () {
            this.buttonRestart.scale.set(
              this.buttonRestart.scale.x * 1.1,
              this.buttonRestart.scale.y * 1.1
            );
          }, this);
        }
        this.buttonRestart.onInputOver.add(function () {
          this.buttonRestart.scale.set(
            this.buttonRestart.scale.x * 1.1,
            this.buttonRestart.scale.y * 1.1
          );
        }, this);
        this.buttonRestart.onInputOut.add(function () {
          this.buttonRestart.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
        }, this);
        this.buttonRestart.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(this.buttonRestart);
      } else {
        this.buttonNewRival = new Phaser.Button(
          this.game,
          MiniBillar.GameVars.gameWidth / 2 +
            50 * MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.gameHeight / 2 + 275,
          "texture_atlas_1",
          this.onClickNewRival,
          this
        );
        this.buttonNewRival.setFrames(
          "btn_new_rival_pressed.png",
          "btn_new_rival.png",
          "btn_new_rival_pressed.png"
        );
        this.buttonNewRival.anchor.set(0.5);
        if (this.game.device.touch) {
          this.buttonNewRival.onInputDown.add(function () {
            this.buttonNewRival.scale.set(
              this.buttonNewRival.scale.x * 1.1,
              this.buttonNewRival.scale.y * 1.1
            );
          }, this);
        }
        this.buttonNewRival.onInputOver.add(function () {
          this.buttonNewRival.scale.set(
            this.buttonNewRival.scale.x * 1.1,
            this.buttonNewRival.scale.y * 1.1
          );
        }, this);
        this.buttonNewRival.onInputOut.add(function () {
          this.buttonNewRival.scale.set(
            MiniBillar.GameVars.scaleXMult,
            MiniBillar.GameVars.scaleYMult
          );
        }, this);
        this.buttonNewRival.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(this.buttonNewRival);
      }
      this.buttonHome = new Phaser.Button(
        this.game,
        MiniBillar.GameVars.gameWidth / 2 -
          120 * MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.gameHeight / 2 + 275,
        "texture_atlas_1",
        this.onClickHome,
        this
      );
      this.buttonHome.setFrames(
        "btn_close_pressed.png",
        "btn_close.png",
        "btn_close_pressed.png"
      );
      this.buttonHome.anchor.set(0.5);
      if (this.game.device.touch) {
        this.buttonHome.onInputDown.add(function () {
          this.buttonHome.scale.set(
            this.buttonHome.scale.x * 1.1,
            this.buttonHome.scale.y * 1.1
          );
        }, this);
      }
      this.buttonHome.onInputOver.add(function () {
        this.buttonHome.scale.set(
          this.buttonHome.scale.x * 1.1,
          this.buttonHome.scale.y * 1.1
        );
      }, this);
      this.buttonHome.onInputOut.add(function () {
        this.buttonHome.scale.set(1, 1);
      }, this);
      this.buttonHome.forceOut = true;
      this.buttonHome.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.add(this.buttonHome);
      MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.WIN);
      if (!MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked) {
        this.animStarBox = new MiniBillar.AnimatedStarBox(game);
        this.animStarBox.y = 475;
        this.animStarBox.x = MiniBillar.GameVars.gameWidth * 0.5;
        this.animStarBox.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(this.animStarBox);
        this.rewardCardContainer = new MiniBillar.RewardCardContainer(game);
        this.rewardCardContainer.y = MiniBillar.GameVars.gameHeight * 0.5;
        this.rewardCardContainer.x = MiniBillar.GameVars.gameWidth * 0.5;
        this.rewardCardContainer.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
        this.add(this.rewardCardContainer);
      }
    }
    init(victoryData) {
      if (!victoryData) {
        throw "Error reading victory data";
      }
      if (victoryData.starUnlocked === 3) {
        this.endGamePortraitContainer.visible = false;
        this.buttonHome.alpha = 0;
        if (this.buttonRestart) {
          this.buttonRestart.visible = false;
        }
        if (this.buttonNewRival) {
          this.buttonNewRival.visible = false;
        }
        if (this.animStarBox) {
          this.animStarBox.y = this.buttonHome.y;
          this.animStarBox.animateGiftBox();
          this.animStarBox.giftBox.boxOpeningTween.onComplete.add(function () {
            this.rewardCardContainer.createAndDisplayCards(
              victoryData.recentlyUnlockedCardIds
            );
            this.rewardCardContainer.animateCardPointsIncrementation(
              victoryData.numberOfCardsUnlocked
            );
            this.buttonHome.setFrames(
              "btn_back_on.png",
              "btn_back_off.png",
              "btn_back_on.png"
            );
            this.buttonHome.scale.x *= -1;
            this.buttonHome.anchor.set(0.5);
            this.buttonHome.x =
              MiniBillar.GameVars.gameWidth - 10 + this.buttonHome.width * 0.5;
            this.buttonHome.y =
              MiniBillar.GameVars.gameHeight -
              10 -
              this.buttonHome.height * 0.5;
            this.game.add
              .tween(this.buttonHome)
              .to(
                {
                  alpha: 1,
                },
                250,
                Phaser.Easing.Cubic.Out,
                true,
                1000
              )
              .onComplete.add(function () {
                const pulseTween = this.game.add.tween(this.buttonHome.scale);
                pulseTween.to(
                  {
                    x: -1.0915 * MiniBillar.GameVars.scaleXMult,
                    y: MiniBillar.GameVars.scaleYMult,
                  },
                  300,
                  Phaser.Easing.Linear.None,
                  false
                );
                pulseTween.to(
                  {
                    x: -MiniBillar.GameVars.scaleXMult,
                    y: 1.0915 * MiniBillar.GameVars.scaleYMult,
                  },
                  700,
                  Phaser.Easing.Elastic.Out
                );
                pulseTween.loop();
                pulseTween.start();
              }, this);
          }, this);
        }
      }
      if (this.animStarBox) {
        for (let i = 0; i < 3; i++) {
          if (i === victoryData.starUnlocked - 1) {
            this.animStarBox.animateStarToFullScale(i);
            break;
          } else {
            this.animStarBox.setStarActive(i);
          }
        }
      }
    }
    onClickReset(b) {
      b.clearFrames();
      MiniBillar.GameVars.paused = false;
      MiniBillar.GameVars.rematch = true;
      MiniBillar.GameManager.enterSoloGame();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickHome(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideVictoryLayer();
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onClickNewRival(b) {
      b.clearFrames();
      MiniBillar.MatchManager.hideVictoryLayer();
      MiniBillar.GameVars.goDirectlyToLobby = true;
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    onDownTransparentLayer() {}
  }
  MiniBillar.VictoryLayer = VictoryLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class MatchManager {
    static init(game, sessionId) {
      MatchManager.game = game;
      MiniBillar.GameVars.gameOver = false;
      MiniBillar.GameVars.english = 0;
      MiniBillar.GameVars.verticalSpin = 0;
      MiniBillar.GameVars.turnSet = true;
      MiniBillar.GameVars.draggingCueBall = false;
      MiniBillar.GameVars.pocketIdWhereBlackFell = -1;
    }
    static update() {
      if (!MiniBillar.GameVars.startMatch || !MiniBillar.GameVars.ballArray) {
        return;
      }
      MiniBillar.GameVars.shotRunning = false;
      for (let i = 0, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
        let ball = MiniBillar.GameVars.ballArray[i];
        if (ball.active && ball.velocity.magnitudeSquared > 0) {
          MiniBillar.GameVars.shotRunning = true;
          break;
        }
      }
      const cueBall = MiniBillar.GameVars.ballArray[0];
      if (cueBall.mc.pocketTween) {
        MiniBillar.GameVars.shotRunning = true;
      }
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.MatchManagerSolo.update();
      } else if (
        MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE
      ) {
        MiniBillar.MatchManagerPVP.update();
      } else if (
        MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
      ) {
        MiniBillar.MatchManagerPVBot.update();
      }
    }
    static showPauseLayer() {
      MiniBillar.PoolState.currentInstance.pauseGame();
    }
    static hideNotificationLayer() {
      MiniBillar.PoolState.currentInstance.hideNotificationLayer();
    }
    static hidePauseLayer() {
      MiniBillar.PoolState.currentInstance.resumeGame();
    }
    static showSoloRetryLayer() {
      MiniBillar.PoolState.currentInstance.showSoloRetryLayer();
    }
    static hideRetryLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.hideRetryLayer();
      }
    }
    static showVictoryLayer(victoryData) {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.showVictoryLayer(victoryData);
      }
    }
    static hideVictoryLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.hideVictoryLayer();
      }
    }
    static showLoseLayer(victoryData) {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.showLoseLayer();
      }
    }
    static hideLoseLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.hideLoseLayer();
      }
    }
    static showAdversaryLeftLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.showAdversaryLeftLayer();
      }
    }
    static hideAdversaryLeftLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.hideAdversaryLeftLayer();
      }
    }
    static ballHasBeenShot(shotData) {
      MiniBillar.GameVars.shotRunning = true;
      MiniBillar.GameVars.turnSet = false;
      MiniBillar.GameVars.shotCount++;
      MiniBillar.PoolState.currentInstance.gui.disableSpinButton();
      MiniBillar.StageContainer.currentInstance.ballHasBeenShot();
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.PoolState.currentInstance.hideNonSOLOTimers();
        if (
          MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY
        ) {
          if (
            MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE
          ) {
            MiniBillar.MatchManagerPVP.ballHasBeenShot(shotData);
          } else if (
            MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
          ) {
            MiniBillar.MatchManagerPVBot.ballHasBeenShot(shotData);
          }
        }
      }
    }
    static reset() {
      MiniBillar.GameVars.paused = false;
      MiniBillar.GameVars.rematch = true;
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.GameManager.enterSoloGame();
      }
    }
    static showSpinCircleLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.showSpinCircleLayer();
      }
    }
    static hideSpinCircleLayer(english, verticalSpin) {
      MiniBillar.GameVars.english = english;
      MiniBillar.GameVars.verticalSpin = verticalSpin;
      MiniBillar.PoolState.currentInstance.hideSpinCircleLayer();
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        Communication.CommunicationManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL_SPIN_SET,
          data: {
            english: MiniBillar.GameVars.english,
            verticalSpin: MiniBillar.GameVars.verticalSpin,
          },
        });
      }
    }
    static resetSpinCircleLayer() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.resetSpinCircleLayer();
      }
    }
    static ballPocketed(ball) {
      const id = ball.id;
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.PoolState.currentInstance.hud.ballPocketed(id);
      }
      if (id !== 0) {
        MiniBillar.StageContainer.currentInstance.addBallToTrail(ball);
        MiniBillar.GameVars.pocketedBalls.push(id);
      }
    }
    static setRedPointPosition() {
      if (MiniBillar.PoolState.currentInstance) {
        MiniBillar.PoolState.currentInstance.gui.setRedPointPosition();
      }
    }
    static setCueAimDirection() {
      MiniBillar.CueContainer.currentInstance.aimDirectionVector =
        new Billiard.Vector2D(
          -Math.cos(MiniBillar.CueContainer.currentInstance.rotation),
          -Math.sin(MiniBillar.CueContainer.currentInstance.rotation)
        );
    }
    static forceCueToShoot(shotData) {
      MiniBillar.CueContainer.currentInstance.shootReceived(
        shotData.vector,
        shotData.deltaScrew,
        shotData.english
      );
    }
    static savePosition(velocity, deltaScrew, english) {
      MiniBillar.GameVars.ballsData.length = 0;
      for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
        let ballData = {
          id: MiniBillar.GameVars.ballArray[i].id,
          active: MiniBillar.GameVars.ballArray[i].active,
          x: MiniBillar.GameVars.ballArray[i].position.x,
          y: MiniBillar.GameVars.ballArray[i].position.y,
        };
        MiniBillar.GameVars.ballsData.push(ballData);
      }
      let ballsData = [];
      for (let i = 0; i < MiniBillar.GameVars.ballsData.length; i++) {
        let ball = MiniBillar.GameVars.ballsData[i];
        let newBall = {
          id: ball.id,
          x: ball.x,
          y: ball.y,
          active: ball.active,
        };
        if (ball.id === 0 && ball.active === false) {
          newBall.x = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][0];
          newBall.y = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][1];
        }
        ballsData.push(newBall);
      }
    }
    static cueBallSet(x, y) {
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
        MiniBillar.MatchManagerPVP.sendCueBallPosition(x, y);
      }
      MiniBillar.StageContainer.currentInstance.newTurn();
    }
    static pocketSelected(pocketId) {
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        if (
          MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE
        ) {
          MiniBillar.MatchManagerPVP.sendSelectedPocket(pocketId);
        } else if (
          MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
        ) {
          MiniBillar.MatchManagerPVBot.sendSelectedPocket(pocketId);
        }
      }
    }
    static rackBalls(rndSeed) {
      let seed = rndSeed || Billiard.Maths.fixNumber(Math.random()).toString();
      const prng = new Phaser.RandomDataGenerator([seed.toString()]);
      if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
        MiniBillar.GameVars.ballArray = [];
        let ballIndexes = [2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15];
        let cueBallObject;
        cueBallObject = new MiniBillar.CueBallObject(
          this.game,
          0,
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][0],
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][1]
        );
        MiniBillar.GameVars.ballArray.push(cueBallObject);
        let ballObject;
        ballObject = new MiniBillar.BallObject(
          this.game,
          1,
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][0],
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][1],
          true
        );
        MiniBillar.GameVars.ballArray.push(ballObject);
        ballObject = new MiniBillar.BallObject(
          this.game,
          8,
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][0],
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][1],
          true
        );
        MiniBillar.GameVars.ballArray.push(ballObject);
        let i = prng.pick(ballIndexes);
        let ballIndexesAux = ballIndexes.slice();
        if (i <= 7) {
          ballIndexesAux = ballIndexesAux.splice(6, 7);
        } else {
          ballIndexesAux = ballIndexesAux.splice(0, 6);
        }
        let j = prng.pick(ballIndexesAux);
        ballObject = new MiniBillar.BallObject(
          this.game,
          i,
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][0],
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][1],
          true
        );
        MiniBillar.GameVars.ballArray.push(ballObject);
        ballObject = new MiniBillar.BallObject(
          this.game,
          j,
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][0],
          MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][1],
          true
        );
        MiniBillar.GameVars.ballArray.push(ballObject);
        let index = ballIndexes.indexOf(i);
        ballIndexes.splice(index, 1);
        index = ballIndexes.indexOf(j);
        ballIndexes.splice(index, 1);
        ballIndexes = MiniBillar.Utils.shuffle(ballIndexes, prng);
        index = 0;
        for (
          let i = 0;
          i < MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO.length;
          i++
        ) {
          if (i !== 0 && i !== 1 && i !== 8 && i !== 3 && i !== 14) {
            ballObject = new MiniBillar.BallObject(
              this.game,
              ballIndexes[index],
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][0],
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][1],
              true
            );
            MiniBillar.GameVars.ballArray.push(ballObject);
            index++;
          }
        }
        for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
          ballObject = MiniBillar.GameVars.ballArray[i];
          let x =
            ballObject.position.x +
            0.05 * Billiard.Maths.fixNumber(prng.frac());
          let y =
            ballObject.position.y +
            0.05 * Billiard.Maths.fixNumber(prng.frac());
          ballObject.position = new Billiard.Vector2D(x, y);
        }
        for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
          let ballData = {
            id: MiniBillar.GameVars.ballArray[i].id,
            active: true,
            x: MiniBillar.GameVars.ballArray[i].position.x,
            y: MiniBillar.GameVars.ballArray[i].position.y,
          };
          MiniBillar.GameVars.ballsData.push(ballData);
        }
      } else {
        MiniBillar.GameVars.ballArray = [];
        for (
          let i = 0;
          i < MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS.length;
          i++
        ) {
          if (i === 0) {
            let cueBallObject;
            cueBallObject = new MiniBillar.CueBallObject(
              this.game,
              i,
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][0],
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][1]
            );
            MiniBillar.GameVars.ballArray.push(cueBallObject);
          } else {
            let ballObject = new MiniBillar.BallObject(
              this.game,
              i,
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][0],
              MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][1],
              true
            );
            let x =
              ballObject.position.x +
              0.05 * Billiard.Maths.fixNumber(prng.frac());
            let y =
              ballObject.position.y +
              0.05 * Billiard.Maths.fixNumber(prng.frac());
            ballObject.position = new Billiard.Vector2D(x, y);
            MiniBillar.GameVars.ballArray.push(ballObject);
          }
        }
      }
    }
    static showAdversaryEmoticon(emoticonID) {
      MiniBillar.PoolState.currentInstance.showAdversaryEmoticon(emoticonID);
    }
    static emoticonSelected(emoticonID) {
      if (!MiniBillar.GameVars.playersSetForPVBot) {
        Communication.CommunicationManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_EMOTICON_SELECTED,
          data: emoticonID,
        });
      }
      MiniBillar.PoolState.currentInstance.emoticonSelected(emoticonID);
    }
    static cueBallSpinSet(data) {
      const english = data.english;
      const verticalSpin = data.verticalSpin;
      MiniBillar.PoolState.currentInstance.gui.cueBallSpinButton.setRedPointPosition(
        english,
        verticalSpin
      );
    }
  }
  MiniBillar.MatchManager = MatchManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class MatchManagerPVBot extends MiniBillar.MatchManager {
    static init(game) {
      super.init(game);
      MatchManagerPVBot.game = game;
      MatchManagerPVBot.doWriteGameData = false;
      MatchManagerPVBot.sidesAlreadyAssigned = false;
      MiniBillar.GameManager.validatePocketedBalls();
      MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
      this.game.state.start("PoolState", true, false);
    }
    static startGame() {
      MiniBillar.MatchManager.rackBalls();
      if (
        MiniBillar.GameVars.firstShot &&
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
      ) {
        MiniBillar.StageContainer.currentInstance.showSetCueBall(
          "Game start and local player's turn"
        );
        MiniBillar.PoolState.currentInstance.showNotificationLayer(
          MiniBillar.GameConstants.NOTIFICATION_NONE,
          true,
          false
        );
      } else {
        MiniBillar.PoolState.currentInstance.showNotificationLayer(
          MiniBillar.GameConstants.NOTIFICATION_NONE,
          false,
          false
        );
      }
      MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(true);
      MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
        [8],
        true
      );
      MatchManagerPVBot.firstTouchedBall =
        MiniBillar.GameConstants.BALL_TYPE_NONE;
      MatchManagerPVBot.pocketedBalls = [];
      Billiard.Bot.init(
        MiniBillar.GameConstants.FRICTION,
        MiniBillar.GameConstants.BALL_RADIUS,
        MiniBillar.GameConstants.POCKET_RADIUS,
        MiniBillar.GameConstants.PHYS_SCALE,
        MiniBillar.GameConstants.MIN_VELOCITY,
        MiniBillar.GameConstants.CUSHION_RESTITUTION,
        MiniBillar.GameConstants.BALL_RESTITUTION,
        MiniBillar.GameVars.extractLineArrayString(),
        MiniBillar.GameVars.extractVertexArrayString(),
        MiniBillar.GameVars.extractPocketArrayString(),
        MatchManagerPVBot.calculateBotDifficulty()
      );
    }
    static update() {
      if (MiniBillar.GameVars.gameOver) {
        return;
      }
      if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
        MiniBillar.GameVars.turnSet = true;
        MatchManagerPVBot.ballsStoppedMoving(
          MatchManagerPVBot.pocketedBalls,
          MatchManagerPVBot.firstTouchedBall,
          MiniBillar.GameVars.pocketIdWhereBlackFell
        );
      }
    }
    static ballPocketed(ball) {
      if (ball.id === 8) {
        MiniBillar.RulesManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED,
          data: null,
        });
      }
      MiniBillar.PoolState.currentInstance.ballPocketed(ball.id);
      MatchManagerPVBot.pocketedBalls.push(ball.id);
      super.ballPocketed(ball);
    }
    static newTurn(state) {
      if (MiniBillar.GameVars.gameOver) {
        return;
      }
      MatchManagerPVBot.implementStateMessages(state);
      MiniBillar.GameVars.firstShot = false;
      MiniBillar.GameVars.shotRunning = false;
      MiniBillar.GameVars.english = 0;
      MiniBillar.GameVars.verticalSpin = 0;
      MatchManagerPVBot.firstTouchedBall =
        MiniBillar.GameConstants.BALL_TYPE_NONE;
      MatchManagerPVBot.pocketedBalls = [];
      MiniBillar.MatchManager.setCueAimDirection();
      MiniBillar.PoolState.currentInstance.newTurn();
    }
    static endPVBotGame(reason) {
      MiniBillar.GameVars.gameOver = true;
      MiniBillar.GameVars.gameEnded = reason;
      MiniBillar.GameVars.paused = true;
      if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
        MatchManagerPVBot.doWriteGameData = true;
        super.showLoseLayer();
      } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon++;
        MatchManagerPVBot.doWriteGameData = true;
        miniplaySend2API("wins", 1);
        let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
        super.showVictoryLayer(victoryData);
      } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
        MiniBillar.PoolState.currentInstance.endGame();
      }
      if (MatchManagerPVBot.doWriteGameData) {
        MiniBillar.GameManager.writeGameData();
      }
      miniplaySend2API("plays", 1);
    }
    static matchOverDueToResignation(playerResigned) {
      if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
        console.error("matchOverDueToResignation()");
      }
      if (playerResigned) {
        MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
      } else {
        MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_WIN);
      }
    }
    static setTouchedBall(ballId) {
      if (ballId === 0) {
        return;
      }
      if (
        MatchManagerPVBot.firstTouchedBall ===
        MiniBillar.GameConstants.BALL_TYPE_NONE
      ) {
        if (ballId < 8) {
          MatchManagerPVBot.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_SOLID;
        } else if (ballId > 8) {
          MatchManagerPVBot.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_STRIPED;
        } else {
          MatchManagerPVBot.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_BLACK;
        }
      } else {
        return;
      }
    }
    static sendSelectedPocket(pocketId) {
      if (
        MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY
      ) {
        MiniBillar.RulesManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
          data: pocketId,
        });
        MiniBillar.GameVars.skipShowingPocketAndCue = false;
      }
    }
    static adversaryCueBallPosition(position) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        let cueBall = MiniBillar.GameVars.ballArray[0];
        cueBall.setPositionReceived(
          position.x * MiniBillar.GameConstants.PHYS_SCALE,
          position.y * MiniBillar.GameConstants.PHYS_SCALE
        );
      }
    }
    static adversaryRotatedCue(cueRotation) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        MiniBillar.CueContainer.currentInstance.moveCue(cueRotation);
      }
    }
    static showPocketSelected(num) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        MiniBillar.StageContainer.currentInstance.showSelectPocket(
          "Setting pocket rival chose"
        );
        MiniBillar.StageContainer.currentInstance.setRivalPocket(num);
        MiniBillar.StageContainer.currentInstance.showCue(
          "adversary selected pocket set"
        );
        MiniBillar.GameVars.skipShowingPocketAndCue = false;
      }
    }
    static shotDataReceived(shotData) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        let shotDataFinal = {
          vector: new Billiard.Vector2D(
            shotData.cueSpeed.vx,
            shotData.cueSpeed.vy
          ),
          deltaScrew: new Billiard.Vector2D(
            shotData.deltaScrew.x,
            shotData.deltaScrew.y
          ),
          english: shotData.english,
        };
        super.forceCueToShoot(shotDataFinal);
      }
    }
    static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
      let data = {
        playerTurn:
          MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER,
        balls: balls,
        firstBall: firstBall,
        blackBallPocket: blackBallPocket,
      };
      MiniBillar.RulesManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED,
        data: data,
      });
      if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
        console.error("sending GameConstants.MESSAGE_TYPE_BALLS_STOPPED");
      }
    }
    static ballHasBeenShot(shotData) {
      MiniBillar.RulesManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_SHOT,
        data: shotData,
      });
      if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
        console.error("sending GameConstants.MESSAGE_TYPE_SHOT");
      }
    }
    static matchFinished(winnerId, delay = 0) {
      if (delay > 0) {
        MatchManagerPVBot.game.time.events.add(
          Phaser.Timer.SECOND,
          function () {
            if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
              console.error("matchFinished()");
            }
            if (
              MiniBillar.GameVars.gameData.playerData.sessionId === winnerId
            ) {
              MatchManagerPVBot.endPVBotGame(
                MiniBillar.GameConstants.PLAYER_WIN
              );
            } else {
              MatchManagerPVBot.endPVBotGame(
                MiniBillar.GameConstants.PLAYER_LOSE
              );
            }
          },
          this
        );
      } else {
        if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
          console.error("matchFinished()");
        }
        if (MiniBillar.GameVars.gameData.playerData.sessionId === winnerId) {
          MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_WIN);
        } else {
          MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_LOSE);
        }
      }
    }
    static cueRotated(cueRotation) {
      MiniBillar.RulesManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION,
        data: cueRotation,
      });
    }
    static calculateBotDifficulty() {
      let base = 3;
      let maximum = 5;
      const played =
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed;
      const won = MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon;
      if (played < 3) {
        return 3;
      }
      if (played < 7) {
        maximum = 5;
      } else if (played < 15) {
        maximum = 7;
      } else {
        maximum = 9;
      }
      let additionalDifficulty = (maximum - base) * (won / played);
      let skill = base + additionalDifficulty;
      return skill;
    }
    static startBotFiringSequence(
      canMoveCueBall,
      canPocketBlackBall,
      botBallsType,
      botWakeTime,
      selectPocketTimeAfterWake,
      shootTimeAfterWake
    ) {
      MatchManagerPVBot.game.time.events.add(
        Phaser.Timer.SECOND * botWakeTime,
        function () {
          if (canMoveCueBall) {
            let cueBallPos = Billiard.Bot.getCueBallPosition(
              MiniBillar.GameVars.extractBallsArrayString(),
              botBallsType
            );
            MiniBillar.RulesManager.sendMessage({
              type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL,
              data: {
                x: cueBallPos.x,
                y: cueBallPos.y,
              },
            });
          }
          const shotData = Billiard.Bot.getShot(
            MiniBillar.GameVars.extractBallsArrayString(),
            MiniBillar.GameVars.shotCount,
            botBallsType === MiniBillar.GameConstants.BALL_TYPE_NONE
              ? ""
              : botBallsType,
            20000
          );
          const deltaScrew =
            MiniBillar.CueContainer.currentInstance.aimDirectionVector.times(
              new Billiard.Vector2D(shotData.velocity.x, shotData.velocity.y)
                .magnitude *
                shotData.screw *
                shotData.verticalSpin
            );
          if (MiniBillar.GameVars.sabotageBot) {
            shotData.velocity.x = 0;
            shotData.velocity.y = 0;
          }
          let shotDataForRulesManager = {
            cueSpeed: {
              vx: shotData.velocity.x,
              vy: shotData.velocity.y,
            },
            deltaScrew: {
              x: deltaScrew.x,
              y: deltaScrew.y,
            },
            english: shotData.english,
          };
          MatchManagerPVBot.game.time.events.add(
            Phaser.Timer.SECOND * selectPocketTimeAfterWake,
            function () {
              if (canPocketBlackBall) {
                MiniBillar.RulesManager.sendMessage({
                  type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
                  data: shotData.pocket8Ball,
                });
              }
              const v = new Billiard.Vector2D(
                shotData.velocity.x,
                shotData.velocity.y
              ).normalize();
              let cueAngle = Math.atan2(-v.y, -v.x);
              MatchManagerPVBot.cueRotated(cueAngle);
            },
            MiniBillar.GameManager
          );
          MatchManagerPVBot.game.time.events.add(
            Phaser.Timer.SECOND * shootTimeAfterWake,
            function () {
              MatchManagerPVBot.ballHasBeenShot(shotDataForRulesManager);
            },
            MiniBillar.GameManager
          );
        },
        MiniBillar.GameManager
      );
    }
    static implementStateMessages(state) {
      MiniBillar.GameVars.skipShowingPocketAndCue = false;
      const isPlayerTurn =
        MiniBillar.GameVars.gameData.playerData.sessionId === state.currentTurn;
      if (state.fault === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
        let cueBall = MiniBillar.GameVars.ballArray[0];
        cueBall.onUpTimeOut();
        MiniBillar.CueContainer.currentInstance.onUpTimeOut();
        MiniBillar.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
      }
      let player =
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        state.human.sessionId
          ? state.human
          : state.bot;
      let adversary =
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        state.bot.sessionId
          ? state.human
          : state.bot;
      if (isPlayerTurn) {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
      } else {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
      }
      if (!MatchManagerPVBot.sidesAlreadyAssigned) {
        if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
          MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(
            MiniBillar.GameConstants.BALL_TYPE_SOLID
          );
          MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
            [9, 10, 11, 12, 13, 14, 15],
            true
          );
          MatchManagerPVBot.sidesAlreadyAssigned = true;
        } else if (
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED
        ) {
          MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(
            MiniBillar.GameConstants.BALL_TYPE_STRIPED
          );
          MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
            [1, 2, 3, 4, 5, 6, 7],
            true
          );
          MatchManagerPVBot.sidesAlreadyAssigned = true;
        }
      }
      if (state.ballInHand) {
        MiniBillar.StageContainer.currentInstance.showSetCueBall(
          "Foul commited by non local player"
        );
      }
      MiniBillar.StageContainer.currentInstance.hideSelectPocket(
        "Not local player's turn or not time to choose pocket"
      );
      MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(false);
      let opponentChoosingPocket = false;
      if (!isPlayerTurn && adversary.canPocketBlackBall) {
        opponentChoosingPocket = true;
        MiniBillar.GameVars.skipShowingPocketAndCue = true;
      }
      MiniBillar.PoolState.currentInstance.showNotificationLayer(
        state.fault,
        isPlayerTurn,
        opponentChoosingPocket
      );
      if (isPlayerTurn && player.canPocketBlackBall) {
        MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
          [8],
          false
        );
        MiniBillar.StageContainer.currentInstance.showSelectPocket(
          "It's time to choose pocket"
        );
        MiniBillar.GameVars.skipShowingPocketAndCue = true;
      }
      if (!isPlayerTurn) {
        MatchManagerPVBot.startBotFiringSequence(
          state.ballInHand,
          adversary.canPocketBlackBall,
          adversary.typeBalls,
          3.6,
          1,
          2
        );
      }
    }
  }
  MiniBillar.MatchManagerPVBot = MatchManagerPVBot;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class MatchManagerPVP extends MiniBillar.MatchManager {
    static init(game, currentTurnPlayer_SessionId) {
      super.init(game);
      MatchManagerPVP.game = game;
      MatchManagerPVP.doWriteGameData = false;
      MatchManagerPVP.sidesAlreadyAssigned = false;
      if (!MiniBillar.GameVars.gameData.playerData) {
        console.error("playerData corrupt");
      }
      if (!MiniBillar.GameVars.adversaryData) {
        console.error("adversaryData corrupt");
      }
      MiniBillar.GameManager.validatePocketedBalls();
      if (
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        currentTurnPlayer_SessionId
      ) {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
      } else {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
      }
      this.game.state.start("PoolState", true, false);
    }
    static startGame() {
      MiniBillar.MatchManager.rackBalls(
        Communication.CommunicationManager.room.id
      );
      if (
        MiniBillar.GameVars.firstShot &&
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER
      ) {
        MiniBillar.StageContainer.currentInstance.showSetCueBall(
          "Game start and local player's turn"
        );
        MiniBillar.PoolState.currentInstance.showNotificationLayer(
          MiniBillar.GameConstants.NOTIFICATION_NONE,
          true,
          false
        );
      } else {
        MiniBillar.PoolState.currentInstance.showNotificationLayer(
          MiniBillar.GameConstants.NOTIFICATION_NONE,
          false,
          false
        );
      }
      MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(true);
      MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
        [8],
        true
      );
      MatchManagerPVP.firstTouchedBall =
        MiniBillar.GameConstants.BALL_TYPE_NONE;
      MatchManagerPVP.pocketedBalls = [];
    }
    static update() {
      if (MiniBillar.GameVars.gameOver) {
        return;
      }
      if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
        MiniBillar.GameVars.turnSet = true;
        MatchManagerPVP.ballsStoppedMoving(
          MatchManagerPVP.pocketedBalls,
          MatchManagerPVP.firstTouchedBall,
          MiniBillar.GameVars.pocketIdWhereBlackFell
        );
      }
    }
    static ballPocketed(ball) {
      if (ball.id === 8) {
        Communication.CommunicationManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED,
          data: null,
        });
      }
      MiniBillar.PoolState.currentInstance.ballPocketed(ball.id);
      MatchManagerPVP.pocketedBalls.push(ball.id);
      super.ballPocketed(ball);
    }
    static newTurn(state) {
      if (MiniBillar.GameVars.gameOver) {
        return;
      }
      MatchManagerPVP.implementStateMessages(state);
      MiniBillar.GameVars.firstShot = false;
      MiniBillar.GameVars.shotRunning = false;
      MiniBillar.GameVars.english = 0;
      MiniBillar.GameVars.verticalSpin = 0;
      MatchManagerPVP.firstTouchedBall =
        MiniBillar.GameConstants.BALL_TYPE_NONE;
      MatchManagerPVP.pocketedBalls = [];
      MiniBillar.GameVars.timerSolo = 20;
      MiniBillar.MatchManager.setCueAimDirection();
      MiniBillar.PoolState.currentInstance.newTurn();
    }
    static endPVPGame(reason) {
      MiniBillar.GameVars.gameOver = true;
      MiniBillar.GameVars.gameEnded = reason;
      MiniBillar.GameVars.paused = true;
      if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
        MatchManagerPVP.doWriteGameData = true;
        super.showLoseLayer();
      } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
        MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon++;
        MatchManagerPVP.doWriteGameData = true;
        miniplaySend2API("wins", 1);
        let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
        super.showVictoryLayer(victoryData);
      } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
        MiniBillar.PoolState.currentInstance.endGame();
      } else if (reason === MiniBillar.GameConstants.ADVERSARY_LEFT_ROOM) {
        super.showAdversaryLeftLayer();
      }
      if (MatchManagerPVP.doWriteGameData) {
        MiniBillar.GameManager.writeGameData();
      }
      miniplaySend2API("plays", 1);
    }
    static matchOverDueToResignation(resigningPlayerSessionId) {
      Communication.CommunicationManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_RESIGN,
        data: MiniBillar.GameVars.gameData.playerData.sessionId,
      });
      Communication.CommunicationManager.leaveRoom();
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("matchOverDueToResignation()");
      }
      if (
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        resigningPlayerSessionId
      ) {
        MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
      } else {
        MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_WIN);
      }
    }
    static adversaryLeftRoomPVP() {
      MiniBillar.GameManager.log("ADVERSARY LEFT ROOM");
      if (
        MiniBillar.GameVars.gameOver ||
        MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE
      ) {
        return;
      }
      if (MiniBillar.LobbyState.currentInstance) {
        MiniBillar.GameManager.enterSplash();
      }
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("adversaryLeftRoomPVP()");
      }
      MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.ADVERSARY_LEFT_ROOM);
    }
    static setTouchedBall(ballId) {
      if (ballId === 0) {
        return;
      }
      if (
        MatchManagerPVP.firstTouchedBall ===
        MiniBillar.GameConstants.BALL_TYPE_NONE
      ) {
        if (ballId < 8) {
          MatchManagerPVP.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_SOLID;
        } else if (ballId > 8) {
          MatchManagerPVP.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_STRIPED;
        } else {
          MatchManagerPVP.firstTouchedBall =
            MiniBillar.GameConstants.BALL_TYPE_BLACK;
        }
      } else {
        return;
      }
    }
    static setTouchedCushion(touchedCushion) {}
    static sendCueBallPosition(x, y) {
      if (
        MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY
      ) {
        Communication.CommunicationManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL,
          data: {
            x: x,
            y: y,
          },
        });
      }
    }
    static sendSelectedPocket(pocketId) {
      if (
        MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY
      ) {
        Communication.CommunicationManager.sendMessage({
          type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
          data: pocketId,
        });
        MiniBillar.GameVars.skipShowingPocketAndCue = false;
      }
    }
    static adversaryCueBallPosition(position) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        let cueBall = MiniBillar.GameVars.ballArray[0];
        cueBall.setPositionReceived(position.x, position.y);
      }
    }
    static adversaryRotatedCue(cueRotation) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        MiniBillar.CueContainer.currentInstance.moveCue(cueRotation);
      }
    }
    static showPocketSelected(num) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        MiniBillar.StageContainer.currentInstance.showSelectPocket(
          "Setting pocket rival chose"
        );
        MiniBillar.StageContainer.currentInstance.setRivalPocket(num);
        MiniBillar.StageContainer.currentInstance.showCue(
          "adversary selected pocket set"
        );
        MiniBillar.GameVars.skipShowingPocketAndCue = false;
      }
    }
    static shotDataReceived(shotData) {
      if (
        MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY
      ) {
        let shotDataFinal = {
          vector: new Billiard.Vector2D(
            shotData.cueSpeed.vx,
            shotData.cueSpeed.vy
          ),
          deltaScrew: new Billiard.Vector2D(
            shotData.deltaScrew.x,
            shotData.deltaScrew.y
          ),
          english: shotData.english,
        };
        super.forceCueToShoot(shotDataFinal);
      }
    }
    static cueRotated(cueRotation) {
      Communication.CommunicationManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION,
        data: cueRotation,
      });
    }
    static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
      let data = {
        playerTurn:
          MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER,
        balls: balls,
        firstBall: firstBall,
        blackBallPocket: blackBallPocket,
      };
      Communication.CommunicationManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED,
        data: data,
      });
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("sending GameConstants.MESSAGE_TYPE_BALLS_STOPPED");
      }
    }
    static ballHasBeenShot(shotData) {
      Communication.CommunicationManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_SHOT,
        data: shotData,
      });
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("sending GameConstants.MESSAGE_TYPE_SHOT");
      }
    }
    static matchFinished(winnerId) {
      this.game.time.events.add(
        650,
        Communication.CommunicationManager.leaveRoom,
        Communication.CommunicationManager
      );
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("matchFinished()");
      }
      if (MiniBillar.GameVars.gameData.playerData.sessionId === winnerId) {
        MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_WIN);
      } else {
        MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_LOSE);
      }
    }
    static playerSet() {
      Communication.CommunicationManager.sendMessage({
        type: MiniBillar.GameConstants.MESSAGE_TYPE_PLAYER_SET,
        data: null,
      });
      if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
        console.error("sending GameConstants.MESSAGE_TYPE_PLAYER_SET");
      }
    }
    static implementStateMessages(state) {
      if (!state.playerA || !state.playerB) {
        return;
      }
      MiniBillar.GameVars.skipShowingPocketAndCue = false;
      const isPlayerTurn =
        MiniBillar.GameVars.gameData.playerData.sessionId === state.currentTurn;
      if (state.fault === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
        let cueBall = MiniBillar.GameVars.ballArray[0];
        cueBall.onUpTimeOut();
        MiniBillar.CueContainer.currentInstance.onUpTimeOut();
        MiniBillar.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
      }
      let player =
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        state.playerA.sessionId
          ? state.playerA
          : state.playerB;
      let adversary =
        MiniBillar.GameVars.gameData.playerData.sessionId ===
        state.playerB.sessionId
          ? state.playerA
          : state.playerB;
      if (isPlayerTurn) {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
      } else {
        MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
      }
      if (!MatchManagerPVP.sidesAlreadyAssigned) {
        if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
          MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(
            MiniBillar.GameConstants.BALL_TYPE_SOLID
          );
          MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
            [9, 10, 11, 12, 13, 14, 15],
            true
          );
          MatchManagerPVP.sidesAlreadyAssigned = true;
        } else if (
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED
        ) {
          MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(
            MiniBillar.GameConstants.BALL_TYPE_STRIPED
          );
          MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
            [1, 2, 3, 4, 5, 6, 7],
            true
          );
          MatchManagerPVP.sidesAlreadyAssigned = true;
        }
      }
      if (state.ballInHand && MiniBillar.StageContainer.currentInstance) {
        MiniBillar.StageContainer.currentInstance.showSetCueBall(
          "Foul commited by non local player"
        );
      }
      MiniBillar.StageContainer.currentInstance.hideSelectPocket(
        "Not local player's turn or not time to choose pocket"
      );
      MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(false);
      let opponentChoosingPocket = false;
      if (!isPlayerTurn && adversary.canPocketBlackBall) {
        opponentChoosingPocket = true;
        MiniBillar.GameVars.skipShowingPocketAndCue = true;
      }
      MiniBillar.PoolState.currentInstance.showNotificationLayer(
        state.fault,
        isPlayerTurn,
        opponentChoosingPocket
      );
      if (isPlayerTurn && player.canPocketBlackBall) {
        MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls(
          [8],
          false
        );
        MiniBillar.StageContainer.currentInstance.showSelectPocket(
          "It's time to choose pocket"
        );
        MiniBillar.GameVars.skipShowingPocketAndCue = true;
      }
    }
  }
  MiniBillar.MatchManagerPVP = MatchManagerPVP;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class MatchManagerSolo extends MiniBillar.MatchManager {
    static init(game) {
      super.init(game);
      MatchManagerSolo.game = game;
      MatchManagerSolo.doWriteGameData = false;
      MatchManagerSolo.currentTurnStreak = 0;
      MatchManagerSolo.comboTicker = 0;
    }
    static startGame() {
      MiniBillar.MatchManager.rackBalls();
      MiniBillar.GameManager.validatePocketedBalls();
      if (MiniBillar.GameVars.gameData.soloTutorial) {
        MiniBillar.PoolState.currentInstance.showNotificationLayer(
          MiniBillar.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS
        );
        MiniBillar.GameVars.gameData.soloTutorial = false;
        MiniBillar.GameManager.writeGameData();
      }
    }
    static update() {
      if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
        this.newTurn();
        MatchManagerSolo.currentTurnStreak = 0;
        MatchManagerSolo.comboTicker = 0;
      }
      if (MatchManagerSolo.comboTicker > 0) {
        MatchManagerSolo.comboTicker -= this.game.time.physicsElapsed;
      } else if (MatchManagerSolo.currentTurnStreak > 0) {
        MatchManagerSolo.currentTurnStreak = 0;
      }
    }
    static ballPocketed(ball) {
      const id = ball.id;
      if (id === 0) {
        MiniBillar.GameVars.playerPoints -= 20;
      } else {
        MiniBillar.GameVars.timerSolo += 10;
        MiniBillar.GameVars.playerPoints += 50;
        MiniBillar.PoolState.currentInstance.animArrow();
        if (MatchManagerSolo.currentTurnStreak === 1) {
          MiniBillar.GameVars.playerPoints += 50;
          MiniBillar.PoolState.currentInstance.hud.showComboEffect(700);
        } else if (MatchManagerSolo.currentTurnStreak >= 2) {
          MiniBillar.GameVars.playerPoints += 50;
          MiniBillar.PoolState.currentInstance.hud.showSuperComboEffect(500);
        }
        MatchManagerSolo.currentTurnStreak++;
        MatchManagerSolo.comboTicker = 3;
      }
      super.ballPocketed(ball);
      if (MiniBillar.GameVars.pocketedBalls.length >= 15) {
        let cueBall = MiniBillar.GameVars.ballArray[0];
        this.game.add
          .tween(cueBall.mc)
          .to(
            {
              alpha: 0,
            },
            350,
            Phaser.Easing.Cubic.Out,
            true
          )
          .onComplete.add(function () {
            MatchManagerSolo.resetBalls();
          }, this);
        this.game.add
          .tween(cueBall.shadow)
          .to(
            {
              alpha: 0,
            },
            350,
            Phaser.Easing.Cubic.Out,
            true
          )
          .onComplete.add(function () {
            MatchManagerSolo.resetBalls();
          }, this);
      }
    }
    static newTurn() {
      if (MiniBillar.GameVars.gameOver) {
        return;
      }
      MiniBillar.GameVars.firstShot = false;
      MiniBillar.GameVars.shotRunning = false;
      MiniBillar.GameVars.turnSet = true;
      MiniBillar.GameVars.english = 0;
      MiniBillar.GameVars.verticalSpin = 0;
      if (MiniBillar.GameVars.pocketedBalls.length >= 15) {
        MatchManagerSolo.resetBalls();
      }
      MiniBillar.MatchManager.setCueAimDirection();
      MiniBillar.PoolState.currentInstance.newTurn();
      MiniBillar.GameVars.ballsData.length = 0;
      for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
        let ballData = {
          id: MiniBillar.GameVars.ballArray[i].id,
          active: MiniBillar.GameVars.ballArray[i].active,
          x: MiniBillar.GameVars.ballArray[i].position.x,
          y: MiniBillar.GameVars.ballArray[i].position.y,
        };
        MiniBillar.GameVars.ballsData.push(ballData);
      }
      MiniBillar.GameManager.log(
        "ballData:" + JSON.stringify(MiniBillar.GameVars.ballsData)
      );
    }
    static resetBalls() {
      MiniBillar.GameVars.pocketedBalls = [];
      MiniBillar.GameVars.ballsData = [];
      MiniBillar.GameVars.canStart = false;
      MiniBillar.GameVars.firstShot = true;
      MiniBillar.GameVars.resetScoreAndTime = false;
      MiniBillar.GameManager.enterSoloGame();
    }
    static computeSoloStats() {
      if (
        MiniBillar.GameVars.playerPoints >
        MiniBillar.GameVars.gameData.statistics.solo.highScore
      ) {
        MiniBillar.GameVars.gameData.statistics.solo.highScore =
          MiniBillar.GameVars.playerPoints;
        MatchManagerSolo.doWriteGameData = true;
      }
    }
    static endSoloGame(reason) {
      MiniBillar.GameVars.gameOver = true;
      MiniBillar.GameVars.gameEnded = reason;
      MiniBillar.GameVars.paused = true;
      MatchManagerSolo.computeSoloStats();
      if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
        super.showSoloRetryLayer();
      } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
        MatchManagerSolo.doWriteGameData = true;
        let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
        super.showVictoryLayer(victoryData);
      } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
        MiniBillar.PoolState.currentInstance.endGame();
      }
      if (MatchManagerSolo.doWriteGameData) {
        MiniBillar.GameManager.writeGameData();
      }
      miniplaySend2API(
        "score",
        MiniBillar.GameVars.gameData.statistics.solo.highScore
      );
      if (MiniBillar.GameVars.timerSolo === -1) {
        miniplaySend2API("plays", 1);
      }
    }
    static startSoloTime() {
      this.game.time.events.loop(
        Phaser.Timer.SECOND,
        function () {
          if (MiniBillar.GameVars.paused || !MiniBillar.GameVars.startMatch) {
            return;
          }
          MiniBillar.GameVars.timerSolo--;
          MiniBillar.PoolState.currentInstance.hud.updateSoloTimer();
          if (MiniBillar.GameVars.timerSolo === -1) {
            const rewardEarned =
              MiniBillar.GameVars.playerPoints >=
              MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD;
            if (rewardEarned) {
              this.endSoloGame(MiniBillar.GameConstants.PLAYER_WIN);
            } else {
              this.endSoloGame(MiniBillar.GameConstants.PLAYER_LOSE);
            }
          }
        },
        this
      );
    }
  }
  MiniBillar.MatchManagerSolo = MatchManagerSolo;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class RulesManager {
    static init(playerData, botData) {
      RulesManager.offlineState = {
        human: null,
        bot: null,
        currentTurn: null,
        changeTurn: false,
        numberShots: 0,
        balls: [],
        ballInHand: true,
        pocketSelected: -1,
        fault: MiniBillar.GameConstants.NOTIFICATION_NONE,
        playerLeft: false,
        winnerSessionId: null,
      };
      for (let i = 0; i < 16; i++) {
        let ball = {
          id: i,
          active: true,
        };
        RulesManager.offlineState.balls.push(ball);
      }
      RulesManager.setupPlayerAndBot(playerData, botData);
    }
    static sendMessage(message) {
      RulesManager.onMessage(message);
    }
    static onMessage(message) {
      switch (message.type) {
        case MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED:
          RulesManager.offlineState.human.ballsMoving = false;
          RulesManager.updateState(message.data);
          RulesManager.decideTurn();
          if (!RulesManager.offlineState.winnerSessionId) {
            MiniBillar.GameManager.onPVBotTurnChange(RulesManager.offlineState);
          } else {
            MiniBillar.MatchManagerPVBot.matchFinished(
              this.offlineState.winnerSessionId
            );
          }
          break;
        case MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED:
          RulesManager.offlineState.pocketSelected = message.data;
          MiniBillar.MatchManagerPVBot.showPocketSelected(message.data);
          break;
        case MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION:
          MiniBillar.MatchManagerPVBot.adversaryRotatedCue(message.data);
          break;
        case MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL:
          MiniBillar.MatchManagerPVBot.adversaryCueBallPosition(message.data);
          break;
        case MiniBillar.GameConstants.MESSAGE_TYPE_SHOT:
          RulesManager.offlineState.human.ballsMoving = true;
          RulesManager.offlineState.bot.ballsMoving = true;
          MiniBillar.MatchManagerPVBot.shotDataReceived(message.data);
          break;
        case MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED:
          if (
            !RulesManager.offlineState.human.canPocketBlackBall &&
            !RulesManager.offlineState.bot.canPocketBlackBall
          ) {
            if (
              RulesManager.offlineState.currentTurn ===
              RulesManager.offlineState.human.sessionId
            ) {
              RulesManager.offlineState.winnerSessionId =
                RulesManager.offlineState.bot.sessionId;
            } else {
              RulesManager.offlineState.winnerSessionId =
                RulesManager.offlineState.human.sessionId;
            }
            MiniBillar.MatchManagerPVBot.matchFinished(
              RulesManager.offlineState.winnerSessionId,
              2
            );
            RulesManager.offlineState.winnerSessionId = null;
          }
          break;
        default:
      }
    }
    static timeOut() {
      RulesManager.offlineState.changeTurn = true;
      RulesManager.offlineState.ballInHand = true;
      RulesManager.offlineState.fault =
        MiniBillar.GameConstants.NOTIFICATION_TIMEOUT;
      RulesManager.offlineState.pocketSelected = -1;
      RulesManager.decideTurn();
      MiniBillar.GameManager.onPVBotTurnChange(RulesManager.offlineState);
    }
    static setupPlayerAndBot(playerData, botData) {
      RulesManager.offlineState.human = playerData;
      RulesManager.offlineState.bot = botData;
      RulesManager.offlineState.currentTurn =
        RulesManager.offlineState.human.sessionId;
      RulesManager.offlineState.numberShots += 1;
    }
    static updateState(data) {
      let balls = data.balls;
      let firstBallTouch = data.firstBall;
      let blackBallPocket = data.blackBallPocket;
      let player;
      if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
        player = this.offlineState.human;
      } else {
        player = this.offlineState.bot;
      }
      let fault = false;
      let typeFault = MiniBillar.GameConstants.NOTIFICATION_NONE;
      if (firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_NONE) {
        fault = true;
        typeFault = MiniBillar.GameConstants.NOTIFICATION_NO_BALL_TOUCHED;
      }
      if (
        firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_BLACK &&
        !player.canPocketBlackBall
      ) {
        fault = true;
        typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
      }
      if (
        firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_SOLID &&
        player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED
      ) {
        fault = true;
        typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
      }
      if (
        firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_STRIPED &&
        player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID
      ) {
        fault = true;
        typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
      }
      for (let i = 0; i < balls.length; i++) {
        if (balls[i] === 0) {
          fault = true;
          typeFault = MiniBillar.GameConstants.NOTIFICATION_CUE_BALL_POTTED;
        } else if (balls[i] === 8 && !player.canPocketBlackBall) {
          fault = true;
          typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
        } else if (
          balls[i] < 8 &&
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED
        ) {
          fault = true;
          typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
        } else if (
          balls[i] > 8 &&
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID
        ) {
          fault = true;
          typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
        }
      }
      let pocketBall = false;
      let win = -1;
      for (let i = 0; i < balls.length; i++) {
        if (balls[i] === 0) {
          continue;
        } else if (
          balls[i] < 8 &&
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID
        ) {
          pocketBall = true;
        } else if (
          balls[i] > 8 &&
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED
        ) {
          pocketBall = true;
        } else if (
          balls[i] !== 8 &&
          player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE
        ) {
          pocketBall = true;
        } else if (balls[i] === 8) {
          if (player.canPocketBlackBall) {
            if (fault) {
              win = 0;
            } else {
              if (this.offlineState.pocketSelected === blackBallPocket) {
                win = 1;
              } else {
                win = 0;
              }
            }
          } else {
            win = 0;
          }
        }
      }
      if (win !== -1) {
        if (win === 0) {
          if (
            this.offlineState.currentTurn === this.offlineState.human.sessionId
          ) {
            this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
          } else {
            this.offlineState.winnerSessionId =
              this.offlineState.human.sessionId;
          }
        } else if (win === 1) {
          if (
            this.offlineState.currentTurn === this.offlineState.human.sessionId
          ) {
            this.offlineState.winnerSessionId =
              this.offlineState.human.sessionId;
          } else {
            this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
          }
        }
      }
      if (
        player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE &&
        !fault
      ) {
        let solidBalls = 0;
        let stripedBalls = 0;
        for (let i = 0; i < balls.length; i++) {
          if (balls[i] === 0 || balls[i] === 8) {
            continue;
          } else if (balls[i] < 8) {
            solidBalls++;
          } else if (balls[i] > 8) {
            stripedBalls++;
          }
        }
        if (solidBalls > 0 && stripedBalls === 0) {
          if (
            this.offlineState.currentTurn === this.offlineState.human.sessionId
          ) {
            this.offlineState.human.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_SOLID;
            this.offlineState.bot.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_STRIPED;
          } else {
            this.offlineState.bot.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_SOLID;
            this.offlineState.human.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_STRIPED;
          }
        } else if (stripedBalls > 0 && solidBalls === 0) {
          if (
            this.offlineState.currentTurn === this.offlineState.human.sessionId
          ) {
            this.offlineState.bot.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_SOLID;
            this.offlineState.human.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_STRIPED;
          } else {
            this.offlineState.human.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_SOLID;
            this.offlineState.bot.typeBalls =
              MiniBillar.GameConstants.BALL_TYPE_STRIPED;
          }
        }
      }
      if (fault) {
        this.offlineState.changeTurn = true;
        this.offlineState.ballInHand = true;
      } else {
        if (pocketBall) {
          this.offlineState.changeTurn = false;
        } else {
          this.offlineState.changeTurn = true;
        }
        this.offlineState.ballInHand = false;
      }
      this.offlineState.fault = typeFault;
      this.offlineState.pocketSelected = -1;
      for (let i = 0; i < balls.length; i++) {
        for (let j = 0; j < this.offlineState.balls.length; j++) {
          if (balls[i] === this.offlineState.balls[j].id) {
            this.offlineState.balls[j].active = false;
            if (this.offlineState.balls[j].id === 0) {
              this.offlineState.balls[j].active = true;
            }
          }
        }
      }
      this.offlineState.bot.canPocketBlackBall =
        RulesManager.canPocketBlackBall(this.offlineState.bot.typeBalls);
      this.offlineState.human.canPocketBlackBall =
        RulesManager.canPocketBlackBall(this.offlineState.human.typeBalls);
    }
    static decideTurn() {
      if (this.offlineState.changeTurn) {
        if (
          this.offlineState.currentTurn === this.offlineState.human.sessionId
        ) {
          this.offlineState.currentTurn = this.offlineState.bot.sessionId;
        } else {
          this.offlineState.currentTurn = this.offlineState.human.sessionId;
        }
      } else {
        if (
          this.offlineState.currentTurn === this.offlineState.human.sessionId
        ) {
          this.offlineState.currentTurn = this.offlineState.human.sessionId;
        } else {
          this.offlineState.currentTurn = this.offlineState.bot.sessionId;
        }
      }
      this.offlineState.numberShots += 1;
    }
    static canPocketBlackBall(typeBalls) {
      let result = true;
      for (let i = 0; i < RulesManager.offlineState.balls.length; i++) {
        if (
          RulesManager.offlineState.balls[i].id === 0 ||
          RulesManager.offlineState.balls[i].id === 8
        ) {
          continue;
        }
        if (!RulesManager.offlineState.balls[i].active) {
          continue;
        }
        if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE) {
          result = false;
        } else if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
          if (RulesManager.offlineState.balls[i].id < 8) {
            result = false;
          }
        } else if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
          if (RulesManager.offlineState.balls[i].id > 8) {
            result = false;
          }
        }
      }
      return result;
    }
  }
  MiniBillar.RulesManager = RulesManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class NotificationLayer extends Phaser.Group {
    constructor(game, type, isPlayerTurn, opponentChoosingPocket) {
      super(game, null, "messages-layer");
      NotificationLayer.currentInstance = this;
      this.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      this.x = MiniBillar.GameVars.gameWidth / 2;
      this.y = MiniBillar.GameVars.gameHeight / 2;
      this.notificationDurationScaleModifier = 0.4;
      this.layerFadeDuration = 1000 * this.notificationDurationScaleModifier;
      this.layerDisplayDuration = 7000 * this.notificationDurationScaleModifier;
      this.alpha = 0;
      this.game.add
        .tween(this)
        .to(
          {
            alpha: 1,
          },
          this.layerFadeDuration,
          Phaser.Easing.Cubic.Out,
          true
        )
        .onComplete.add(function () {
          NotificationLayer.currentInstance.hideNotification();
        }, this);
      if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
        this.showNonSOLONotification(
          type,
          isPlayerTurn,
          opponentChoosingPocket
        );
      } else {
        if (
          type === MiniBillar.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS
        ) {
          const transparentBackground = new Phaser.Sprite(
            this.game,
            0,
            145,
            this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE)
          );
          transparentBackground.anchor.set(0.5, 0);
          transparentBackground.alpha = 0.6;
          this.add(transparentBackground);
          let rulesText = new Phaser.Text(
            this.game,
            0,
            160,
            MiniBillar.GameConstants.RULES_TEXT,
            {
              font: this.game.device.desktop
                ? "24px Oswald-DemiBold"
                : "34px Oswald-DemiBold",
              fontWeight: "600",
              fill: "#e7f6f8",
              align: "center",
              stroke: "#2f3237",
              strokeThickness: 3,
            }
          );
          rulesText.anchor.set(0.5, 0);
          MiniBillar.Utils.colourRulesText(rulesText);
          this.add(rulesText);
          transparentBackground.scale.set(
            (rulesText.width + 40) / 64,
            (rulesText.height + 30) / 64
          );
          this.layerDisplayDuration =
            16000 * this.notificationDurationScaleModifier;
        }
      }
    }
    hideNotification() {
      if (!this.game) {
        return;
      }
      this.game.add
        .tween(this)
        .to(
          {
            alpha: 0,
          },
          this.layerFadeDuration,
          Phaser.Easing.Cubic.Out,
          true,
          this.layerDisplayDuration
        )
        .onComplete.add(function () {
          MiniBillar.PoolState.currentInstance.hideNotificationLayer();
        }, this);
    }
    showNonSOLONotification(type, isPlayerTurn, opponentChoosingPocket) {
      const turnImageSwipeDuration =
        1000 * this.notificationDurationScaleModifier;
      const turnImageDisplayDuration =
        5000 * this.notificationDurationScaleModifier;
      let text = new Phaser.Text(this.game, 0, 0, "", {
        font: "30px Oswald-DemiBold",
        fontWeight: "600",
        fill: "#EB3359",
        align: "center",
      });
      text.stroke = "#673952";
      text.strokeThickness = 5;
      text.anchor.set(0.5);
      this.add(text);
      const turnImage = new Phaser.Image(
        this.game,
        MiniBillar.GameVars.gameWidth + 100,
        240,
        "texture_atlas_1",
        isPlayerTurn ? "your_turn.png" : "rivals_turn.png"
      );
      turnImage.anchor.set(0.5);
      this.add(turnImage);
      this.game.add
        .tween(turnImage)
        .to(
          {
            x: 50,
          },
          turnImageSwipeDuration,
          Phaser.Easing.Exponential.Out,
          true,
          this.layerFadeDuration
        )
        .onComplete.add(function () {
          this.game.add
            .tween(turnImage)
            .to(
              {
                x: turnImage.x - 100,
              },
              turnImageDisplayDuration,
              Phaser.Easing.Linear.None,
              true
            )
            .onComplete.add(function () {
              this.game.add.tween(turnImage).to(
                {
                  x: -MiniBillar.GameVars.gameWidth - 100,
                },
                turnImageSwipeDuration,
                Phaser.Easing.Exponential.In,
                true
              );
            }, this);
        }, this);
      if (type === MiniBillar.GameConstants.NOTIFICATION_CUE_BALL_POTTED) {
        text.text = "CUE BALL POCKETED";
      } else if (
        type === MiniBillar.GameConstants.NOTIFICATION_NO_BALL_TOUCHED
      ) {
        text.text = "NO BALL TOUCHED";
      } else if (type === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
        text.text = "OUT OF TIME";
      } else if (
        type === MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED
      ) {
        text.text = "WRONG BALL POCKETED";
      } else if (
        type === MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED
      ) {
        text.text = "WRONG BALL TOUCHED FIRST";
      } else if (type === MiniBillar.GameConstants.NOTIFICATION_NONE) {
        text.visible = false;
      }
      if (opponentChoosingPocket) {
        if (text.visible) {
          text.text += "\n";
        } else {
          text.visible = true;
        }
        text.text += "OPPONENT CHOOSING POCKET";
      }
      const iconFoul = new Phaser.Image(
        this.game,
        0,
        text.y,
        "texture_atlas_1",
        "icon_foul.png"
      );
      iconFoul.anchor.set(1, 0.5);
      const iconHalfWidth = iconFoul.width * 0.5;
      text.x += iconHalfWidth * 1.2;
      iconFoul.x = text.x - text.width * 0.5;
      iconFoul.visible = text.visible;
      this.add(iconFoul);
    }
  }
  MiniBillar.NotificationLayer = NotificationLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class RewardCard extends Phaser.Group {
    constructor(
      game,
      x,
      y,
      cardId,
      currentPoints = -1,
      insideScaledObject = true,
      clickable = false
    ) {
      super(game, null, "reward-card");
      if (!insideScaledObject) {
        this.scale.set(
          MiniBillar.GameVars.scaleXMult,
          MiniBillar.GameVars.scaleYMult
        );
      }
      this.x = x;
      this.y = y;
      this.cardId = cardId;
      this.cardType = MiniBillar.RewardsManager.getCardType(this.cardId);
      this.parentRail = null;
      this.pointsToIncrement = 0;
      this.incrementPointsDt = 0;
      this.incrementPointsCounter = 0;
      if (currentPoints < 0) {
        this.points = MiniBillar.RewardsManager.getCardPoints(this.cardId);
      } else {
        this.points = currentPoints;
      }
      const cardImageNameWithExtension = this.cardId + ".png";
      this.cardMaxPoints = MiniBillar.RewardsManager.getMaxForCardType(
        this.cardType
      );
      this.cardMaxPointsLabel = "/" + this.cardMaxPoints;
      this.boxContainerImage = new Phaser.Image(
        this.game,
        0,
        0,
        "texture_atlas_5",
        cardImageNameWithExtension
      );
      this.boxContainerImage.anchor.set(0.5);
      if (clickable) {
        this.boxContainerImage.inputEnabled = true;
      }
      this.add(this.boxContainerImage);
      const progressBarBG = new Phaser.Graphics(this.game, 0, 0);
      progressBarBG.beginFill(0x006f4c);
      this.add(progressBarBG);
      this.progressBar = new Phaser.Image(
        this.game,
        0,
        120,
        "texture_atlas_1",
        "progress_bar.png"
      );
      this.progressBar.scale.x *= 1.03;
      this.progressBar.scale.y *= 1.1;
      this.progressBar.anchor.set(0.5);
      this.add(this.progressBar);
      progressBarBG.drawRect(
        0,
        -this.progressBar.height / 2,
        this.progressBar.width,
        this.progressBar.height
      );
      progressBarBG.x = this.progressBar.x - this.progressBar.width / 2;
      progressBarBG.y = this.progressBar.y;
      this.progressMaskRectangle = new Phaser.Graphics(
        this.game,
        this.progressBar.x - this.progressBar.width / 2,
        this.progressBar.y
      );
      this.progressMaskRectangle.beginFill(0xffffff);
      this.progressMaskRectangle.drawRect(
        0,
        -this.progressBar.height / 2,
        this.progressBar.width,
        this.progressBar.height
      );
      this.progressMaskRectangle.endFill();
      this.progressMaskRectangle.renderable = false;
      const maskScale = Phaser.Math.clamp(
        currentPoints / this.cardMaxPoints,
        0.01,
        1
      );
      this.progressMaskRectangle.scale.x = maskScale;
      this.add(this.progressMaskRectangle);
      this.progressBar.mask = this.progressMaskRectangle;
      let progressText = currentPoints.toString() + this.cardMaxPointsLabel;
      this.progressLabel = new Phaser.Text(
        this.game,
        this.progressBar.x,
        this.progressBar.y + 3,
        progressText,
        {
          font: "20px Oswald-DemiBold",
          fontWeight: "400",
          fill: "#E5FFFF",
          align: "center",
        }
      );
      this.progressLabel.anchor.set(0.5);
      this.add(this.progressLabel);
      this.boxContainerImage.bringToTop();
      this.equipButton = new Phaser.Button(
        this.game,
        this.progressBar.x,
        this.progressBar.y + 1,
        "texture_atlas_1"
      );
      this.equipButton.anchor.set(0.5);
      if (this.game.device.touch) {
        this.equipButton.onInputDown.add(
          function () {
            this.equipButton.scale.set(
              this.equipButton.scale.x * 1.05,
              this.equipButton.scale.y * 1.05
            );
          },
          this,
          5
        );
      }
      this.equipButton.onInputOver.add(
        function () {
          this.equipButton.scale.set(
            this.equipButton.scale.x * 1.05,
            this.equipButton.scale.y * 1.05
          );
        },
        this,
        5
      );
      this.equipButton.onInputOut.add(
        function () {
          this.equipButton.scale.set(1, 1);
        },
        this,
        5
      );
      this.equipButton.events.onInputUp.add(this.onClickEquip, this, 5);
      this.equipButton.setFrames(
        "btn_equip_pressed.png",
        "btn_equip.png",
        "btn_equip_pressed.png",
        "btn_equip.png"
      );
      this.add(this.equipButton);
      this.equippedImage = new Phaser.Image(
        this.game,
        this.progressBar.x,
        this.progressBar.y + 1,
        "texture_atlas_1",
        "equipped.png"
      );
      this.equippedImage.anchor.set(0.5);
      this.add(this.equippedImage);
      this.equipButton.bringToTop();
      if (currentPoints === this.cardMaxPoints) {
        this.unlocked = true;
        if (
          MiniBillar.GameVars.gameData.playerData.equipedCue === this.cardId ||
          MiniBillar.GameVars.gameData.equippedTable === this.cardId
        ) {
          this.equippedImage.visible = true;
          this.equipButton.visible = false;
        } else {
          this.equippedImage.visible = false;
          this.progressLabel.visible = false;
        }
      } else {
        this.unlocked = false;
        this.equippedImage.visible = false;
        this.equipButton.visible = false;
      }
    }
    update() {
      if (this.pointsToIncrement > 0) {
        if (this.incrementPointsCounter < 0) {
          this.incrementPointsCounter = this.incrementPointsDt;
          this.pointsToIncrement--;
          if (this.points >= this.cardMaxPoints) {
            this.pointsToIncrement = 0;
            this.points = this.cardMaxPoints;
            this.progressLabel.text = "UNLOCKED!";
          } else {
            this.progressLabel.text =
              (this.points - this.pointsToIncrement).toString() +
              this.cardMaxPointsLabel;
          }
        } else {
          this.incrementPointsCounter -= this.game.time.physicsElapsedMS;
        }
      }
    }
    onClickEquip() {
      this.equipButton.scale.set(1, 1);
      this.equipButton.visible = false;
      this.equippedImage.visible = true;
      if (!this.parentRail) {
        return;
      }
      let oldSelected;
      if (this.cardType === "cue") {
        oldSelected = MiniBillar.GameVars.gameData.playerData.equipedCue;
      } else {
        oldSelected = MiniBillar.GameVars.gameData.equippedTable;
      }
      if (this.cardId === oldSelected || !this.unlocked) {
        return;
      } else {
        let unequipSuccessful = false;
        for (let card of this.parentRail.cardArray) {
          if (card.cardId === oldSelected) {
            unequipSuccessful = true;
            card.unequip();
            break;
          }
        }
        if (unequipSuccessful) {
          MiniBillar.GameManager.onItemEquiChange(this.cardType, this.cardId);
        }
      }
      MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
    }
    unequip() {
      this.equipButton.visible = true;
      this.equippedImage.visible = false;
      this.progressLabel.visible = false;
    }
    animateToNewestCardPoint(incrementValue) {
      let oldProgValue = Phaser.Math.clamp(
        (this.points - incrementValue) / this.cardMaxPoints,
        0.01,
        1
      );
      this.progressMaskRectangle.scale.x = oldProgValue;
      let currentProgValue = Phaser.Math.clamp(
        this.points / this.cardMaxPoints,
        0.01,
        1
      );
      this.progressLabel.text =
        Math.max(0, this.points - incrementValue).toString() +
        this.cardMaxPointsLabel;
      const tweenDelay = 1000;
      const tweenDuration = 1500;
      this.game.add
        .tween(this.progressMaskRectangle.scale)
        .to(
          {
            x: currentProgValue,
          },
          tweenDuration,
          Phaser.Easing.Cubic.Out,
          true,
          tweenDelay
        )
        .onStart.add(function () {
          this.pointsToIncrement = incrementValue;
          this.incrementPointsDt = (tweenDuration / incrementValue) * 0.8;
          this.incrementPointsCounter = this.incrementPointsDt;
        }, this);
    }
    setParentRail(parentRail) {
      this.parentRail = parentRail;
    }
  }
  MiniBillar.RewardCard = RewardCard;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class RewardCardContainer extends Phaser.Group {
    constructor(game) {
      super(game, null, "cards-displayer");
      this.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
    }
    createAndDisplayCards(cardIds) {
      this.rewardCards = [];
      for (let i = 0; i < cardIds.length; i++) {
        let rc = new MiniBillar.RewardCard(this.game, 0, 0, cardIds[i]);
        this.rewardCards.push(rc);
        this.add(this.rewardCards[i]);
        rc.scale.x = 0.00001;
        rc.alpha = 0;
        this.game.add
          .tween(rc.scale)
          .to(
            {
              x: 1,
            },
            600,
            Phaser.Easing.Bounce.Out,
            true,
            i * 250
          )
          .onStart.add(function () {
            MiniBillar.AudioManager.playEffect(
              MiniBillar.AudioManager.GIFT_CARD_SWISH
            );
          }, this);
        this.game.add.tween(rc).to(
          {
            alpha: 1,
          },
          600,
          Phaser.Easing.Cubic.Out,
          true,
          i * 250
        );
      }
      let cardXPos = -256;
      const intervalX = 256;
      if (this.rewardCards.length === 2) {
        cardXPos = -128;
      } else if (this.rewardCards.length === 1) {
        cardXPos = 0;
      }
      for (let i = 0; i < this.rewardCards.length; i++) {
        this.rewardCards[i].x = cardXPos;
        cardXPos += intervalX;
      }
    }
    animateCardPointsIncrementation(incrementValues) {
      for (let i = 0; i < this.rewardCards.length; i++) {
        const card = this.rewardCards[i];
        card.animateToNewestCardPoint(incrementValues[i]);
      }
    }
  }
  MiniBillar.RewardCardContainer = RewardCardContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class PreloadBar extends Phaser.Group {
    constructor(game) {
      super(game, null, "preloadbar");
      this.x = MiniBillar.GameVars.gameWidth / 2;
      this.y = 395;
      this.f = 0;
      this.scale.x = MiniBillar.GameVars.scaleXMult;
      this.scale.y = MiniBillar.GameVars.scaleYMult;
      this.preloadCue = new Phaser.Image(
        this.game,
        -PreloadBar.RECT_WIDTH / 2,
        0,
        "preload_cue"
      );
      this.preloadCue.anchor.set(1, 0.5);
      this.add(this.preloadCue);
      this.preloadCueBall = new Phaser.Image(
        this.game,
        PreloadBar.RECT_WIDTH / 2 + 22,
        0,
        "preload_cue_ball"
      );
      this.preloadCueBall.anchor.set(0.5);
      this.add(this.preloadCueBall);
      const graphics = new Phaser.Graphics(this.game);
      graphics.lineStyle(2, 0xffffff);
      graphics.drawRoundedRect(
        -PreloadBar.RECT_WIDTH / 2,
        -PreloadBar.RECT_HEIGTH / 2,
        PreloadBar.RECT_WIDTH,
        PreloadBar.RECT_HEIGTH,
        10
      );
      this.add(graphics);
      this.percentageLabel = new Phaser.Text(this.game, 0, 52, "0%", {
        font: "34px Oswald-DemiBold",
        fontWeight: "400",
        fill: "#FFFFFF",
      });
      this.percentageLabel.anchor.set(0.5);
      this.percentageLabel.visible = false;
      this.add(this.percentageLabel);
    }
    update() {
      super.update();
      this.f++;
      if (this.f === 10) {
        this.percentageLabel.visible = true;
      }
    }
    updateLoadedPercentage(loadProgress) {
      this.percentageLabel.text = loadProgress + "%";
      this.preloadCue.x =
        -PreloadBar.RECT_WIDTH / 2 +
        (loadProgress / 100) * (PreloadBar.RECT_WIDTH + 6);
      if (loadProgress === 100) {
        this.game.add
          .tween(this.preloadCue)
          .to(
            {
              x: this.preloadCue.x - 36,
            },
            300,
            Phaser.Easing.Cubic.Out,
            true
          )
          .onComplete.add(function () {
            this.game.add
              .tween(this.preloadCue)
              .to(
                {
                  x: this.preloadCue.x + 40,
                },
                100,
                Phaser.Easing.Cubic.Out,
                true
              )
              .onComplete.add(function () {
                this.game.add
                  .tween(this.preloadCueBall)
                  .to(
                    {
                      x:
                        (MiniBillar.GameVars.gameWidth / 2 + 50) *
                        MiniBillar.GameVars.scaleXMultInverse,
                    },
                    250,
                    Phaser.Easing.Cubic.Out,
                    true
                  )
                  .onComplete.add(function () {
                    MiniBillar.PreLoader.currentInstance.cueBallDisappeared();
                  }, this);
              }, this);
          }, this);
      }
    }
  }
  PreloadBar.RECT_WIDTH = 290;
  PreloadBar.RECT_HEIGTH = 30;
  MiniBillar.PreloadBar = PreloadBar;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function (MiniBillar) {
  class PreLoader extends Phaser.State {
    init() {
      PreLoader.currentInstance = this;
    }
    preload() {
      Phaser.Canvas.setBackgroundColor(this.game.canvas, "#000000");
      this.generateBitmapData();
      this.composeScene();
      this.loadAssets();
    }
    create() {}
    cueBallDisappeared() {
      this.game.time.events.add(
        MiniBillar.GameConstants.DEVELOPMENT ? 50 : 350,
        function () {
          MiniBillar.GameManager.onGameAssetsLoaded();
        },
        this
      );
    }
    shutdown() {
      PreLoader.currentInstance = this;
      super.shutdown();
    }
    updateLoadedPercentage() {
      this.preloadBar.updateLoadedPercentage(this.load.progress);
    }
    generateBitmapData() {
      let bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BLACK_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#000000";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BLACK_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#000000";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.WHITE_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#FFFFFF";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.RED_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#FF0000";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.ORANGE_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#FF9900";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.YELLOW_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#FFFF00";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.GREEN_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#00FF00";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BLUE_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#0f1726";
      bmd.ctx.fill();
      bmd = this.game.add.bitmapData(
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.GREY_SQUARE,
        true
      );
      bmd.ctx.beginPath();
      bmd.ctx.rect(
        0,
        0,
        MiniBillar.GameConstants.BITMAP_SIZE,
        MiniBillar.GameConstants.BITMAP_SIZE
      );
      bmd.ctx.fillStyle = "#2F3237";
      bmd.ctx.fill();
    }
    composeScene() {
      this.add.text(
        MiniBillar.GameVars.gameWidth * 0.5,
        MiniBillar.GameVars.gameHeight * 0.5,
        "ABCDEFG",
        {
          font: "30px Oswald-DemiBold",
          fontWeight: "400",
          fill: "#542200",
          align: "center",
        }
      );
      this.add.text(
        MiniBillar.GameVars.gameWidth * 0.5,
        MiniBillar.GameVars.gameHeight * 0.5,
        "ABCDEFG",
        {
          font: "30px Oswald-Medium",
          fontWeight: "400",
          fill: "#542200",
          align: "center",
        }
      );
      const background = this.add.image(
        MiniBillar.GameVars.gameWidth / 2,
        MiniBillar.GameVars.gameHeight / 2,
        "preload_background"
      );
      background.scale.set(
        MiniBillar.GameVars.scaleXMult,
        MiniBillar.GameVars.scaleYMult
      );
      background.anchor.set(0.5);
      this.preloadBar = new MiniBillar.PreloadBar(this.game);
      this.add.existing(this.preloadBar);
    }
    loadAssets() {
      if (MiniBillar.GameConstants.DEVELOPMENT) {
        this.load.atlasJSONArray(
          "texture_atlas_0",
          "/texture_atlas_0.png",
          "/texture_atlas_0.json"
        );
      }
      this.load.atlasJSONArray(
        "texture_atlas_1",
        "/texture_atlas_1.png",
        "/texture_atlas_1.json"
      );
      this.load.atlasJSONArray(
        "texture_atlas_3",
        "/texture_atlas_3.png",
        "/texture_atlas_3.json"
      );
      this.load.atlasJSONArray(
        "texture_atlas_2",
        "/texture_atlas_2.jpg",
        "/texture_atlas_2.json"
      );
      this.load.atlasJSONArray(
        "texture_atlas_4",
        "/texture_atlas_4.png",
        "/texture_atlas_4.json"
      );
      this.load.atlasJSONArray(
        "texture_atlas_5",
        "/texture_atlas_5.png",
        "/texture_atlas_5.json"
      );
      this.load.image("more-games", "/neon_pool_io.png");
      this.load.audiosprite(
        "audio-sprite",
        ["/audio/audiosprite.mp3", "/audio/audiosprite.ogg"],
        "/audio/audiosprite.json"
      );
      this.load.json("card-data", "/config/card_data.json");
      this.load.onFileComplete.add(this.updateLoadedPercentage, this);
    }
  }
  MiniBillar.PreLoader = PreLoader;
})(MiniBillar || (MiniBillar = {}));

var PhaserCachebuster;
(function (PhaserCachebuster) {
  class CacheBuster extends Phaser.Plugin {
    constructor(game, parent) {
      super(game, parent);
      this.patchLoader();
    }
    patchLoader() {
      Object.defineProperty(Phaser.Loader, "cacheBuster", {
        value: null,
      });
      Phaser.Loader.prototype.transformUrl = function (url, file) {
        if (!url) {
          return "";
        }
        if (this.cacheBuster !== null && null === url.match(/^(data:)/)) {
          url += "?v=" + this.cacheBuster;
        }
        if (url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
          return url;
        } else {
          return this.baseURL + file.path + url;
        }
      };
    }
  }
  PhaserCachebuster.CacheBuster = CacheBuster;
})(PhaserCachebuster || (PhaserCachebuster = {}));
var MiniBillar;
(function (MiniBillar) {
  class Utils {
    static colourRulesText(rulesText) {
      const rulesColorOffset = Utils.getNumberOfDigitsInNumber(
        MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD
      );
      Utils.colourText(
        rulesText,
        115,
        rulesColorOffset + 50,
        "#fff562",
        "#1D2836"
      );
    }
    static getRandomUsernameList() {
      return [
        "AllyCookie",
        "Branstoqu",
        "Bur_gizer",
        "Chatomadli",
        "ChoneKnotLou",
        "Conceme41",
        "CoooooopsFree",
        "Darklessra",
        "Garioney",
        "GrabsDrummer",
        "IamaBloom",
        "1k1nt1cs",
        "Issueinters",
        "Knottownce",
        "LightN_inja",
        "Multing",
        "Ravag3rma",
        "RockerPersonal",
        "Slip_korks",
        "Sportswaba",
        "Stori3sDas",
        "TagzBall",
        "0Th3reCoverag3",
        "UnowPlus",
        "Fistro",
        "CountOfMor",
        "Mistery2005",
        "KineticForce",
        "M. Rajoy",
        "ChumbaWumba",
        "PlayerTotal",
        "Barcelono",
        "BrainDamage",
        "LobotomyHero",
        "MiniRock",
        "LettuceJuice",
        "Camaleon",
        "Bloom",
        "buTTer",
        "tenderGlobe",
        "ColdFeet",
        "LovelLove",
        "StronGGGG",
        "PoopSY",
        "kidd_2005",
        "thunderblade",
        "Priapus",
        "koksy",
      ];
    }
    static getRandomAvatarImageList() {
      return [
        "billar_m01",
        "billar_m02",
        "billar_m03",
        "billar_m04",
        "billar_m05",
        "billar_m06",
        "billar_m07",
        "billar_m08",
        "billar_w01",
        "billar_w02",
        "billar_w03",
        "billar_w04",
        "billar_w05",
        "billar_w06",
        "billar_w07",
        "billar_w08",
      ];
    }
    static colourText(
      rulesText,
      startIndex,
      charCount,
      textColour,
      strokeColour
    ) {
      const oldFill = rulesText.fill;
      const oldStroke = rulesText.stroke;
      rulesText.addColor(textColour, startIndex);
      rulesText.addColor(oldFill, startIndex + charCount);
      if (strokeColour) {
        rulesText.addStrokeColor(strokeColour, startIndex);
        rulesText.addStrokeColor(oldStroke, startIndex + charCount);
      }
    }
    static truncateName(name, limit = 10) {
      if (name.length > limit) {
        name = name.substr(0, limit);
        name += "...";
      }
      return name;
    }
    static validNumber(x) {
      return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    static getNumberOfDigitsInNumber(num) {
      if (num < 0) {
        throw "Invalid. Number must be larger than 0";
      }
      let digits = 1;
      let m = 10;
      while (m <= num) {
        digits++;
        m *= 10;
      }
      return digits;
    }
    static timeToString(time) {
      let minutes = Math.floor(time / 60);
      let seconds = time - minutes * 60;
      if (minutes < 10) {
        minutes = "0" + minutes;
      }
      if (seconds < 10) {
        seconds = "0" + seconds;
      }
      return minutes + ":" + seconds;
    }
    static shuffle(array, prng) {
      let currentIndex = array.length,
        temporaryValue,
        randomIndex;
      while (0 !== currentIndex) {
        randomIndex = Math.floor(prng.frac() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }
      return array;
    }
    static centerPoint(array) {
      let x = 0;
      let y = 0;
      for (let i = 0; i < array.length; i++) {
        x += array[i].x;
        y += array[i].y;
      }
      return {
        x: x / array.length,
        y: y / array.length,
      };
    }
    static parseString(json) {
      json = json.replace(/id:/g, '"id":');
      json = json.replace(/active/g, '"active"');
      json = json.replace(/x:/g, '"x":');
      json = json.replace(/y:/g, '"y":');
      json = json.replace(/ballsData/g, '"ballsData"');
      json = json.replace(/english/g, '"english"');
      json = json.replace(/deltaScrewX/g, '"deltaScrewX"');
      json = json.replace(/deltaScrewY/g, '"deltaScrewY"');
      json = json.replace(/playerId/g, '"playerId"');
      return JSON.parse(json);
    }
    static stringify(object) {
      let str = JSON.stringify(object);
      return str.replace(/\"([^(\")"]+)\":/g, "$1:");
    }
    static createAnimFramesArr(
      filename,
      framesCount,
      reverse = false,
      timesToRepeatFinalFrame = 0,
      blankBufferBeforeAnim = 0
    ) {
      let frames = [];
      for (let i = 0; i < framesCount; i++) {
        if (i === 0 && blankBufferBeforeAnim > 0) {
          for (let j = 0; j < blankBufferBeforeAnim; j++) {
            frames.push("blank.png");
          }
        }
        frames.push(
          filename +
            "_" +
            (reverse ? framesCount - 1 - i : i).toString() +
            ".png"
        );
        if (i === framesCount - 1 && timesToRepeatFinalFrame > 0) {
          for (let j = 0; j < timesToRepeatFinalFrame; j++) {
            frames.push(
              filename +
                "_" +
                (reverse ? framesCount - 1 - i : i).toString() +
                ".png"
            );
          }
        }
      }
      return frames;
    }
    static hash(str) {
      let hash = 5381;
      let i = str.length;
      while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
      }
      return hash >>> 0;
    }
  }
  MiniBillar.Utils = Utils;
})(MiniBillar || (MiniBillar = {}));
//# sourceMappingURL=mini-billar.min.js.map
